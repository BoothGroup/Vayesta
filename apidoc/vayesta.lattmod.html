

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>vayesta.lattmod &mdash; Vayesta 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=8d563738"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="vayesta.libs" href="vayesta.libs.html" />
    <link rel="prev" title="vayesta.core.types.wf" href="vayesta.core.types.wf.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Vayesta
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Vayesta</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">API</a></li>
      <li class="breadcrumb-item active">vayesta.lattmod</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/apidoc/vayesta.lattmod.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="vayesta-lattmod">
<h1>vayesta.lattmod<a class="headerlink" href="#vayesta-lattmod" title="Link to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-vayesta.lattmod.bethe">
<span id="vayesta-lattmod-bethe"></span><h2>vayesta.lattmod.bethe<a class="headerlink" href="#module-vayesta.lattmod.bethe" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="vayesta.lattmod.bethe.hubbard1d_bethe_energy">
<span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.bethe.</span></span><span class="sig-name descname"><span class="pre">hubbard1d_bethe_energy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1e-14,</span> <span class="pre">96.60397409788614)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/bethe.html#hubbard1d_bethe_energy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.bethe.hubbard1d_bethe_energy" title="Link to this definition"></a></dt>
<dd><p>Exact total energy per site for the 1D Hubbard model in the thermodynamic limit.</p>
<p>from DOI: 10.1103/PhysRevB.77.045133.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="vayesta.lattmod.bethe.hubbard1d_bethe_docc">
<span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.bethe.</span></span><span class="sig-name descname"><span class="pre">hubbard1d_bethe_docc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1e-14,</span> <span class="pre">96.60397409788614)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/bethe.html#hubbard1d_bethe_docc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.bethe.hubbard1d_bethe_docc" title="Link to this definition"></a></dt>
<dd><p>Exact on-site double occupancy for the 1D Hubbard model in the thermodynamic limit.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="vayesta.lattmod.bethe.hubbard1d_bethe_docc_numdiff">
<span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.bethe.</span></span><span class="sig-name descname"><span class="pre">hubbard1d_bethe_docc_numdiff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">du</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/bethe.html#hubbard1d_bethe_docc_numdiff"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.bethe.hubbard1d_bethe_docc_numdiff" title="Link to this definition"></a></dt>
<dd><p>Exact on-site double occupancy for the 1D Hubbard model in the thermodynamic limit.</p>
<p>Calculated from the numerical differentiation of the exact Bethe ansatz energy.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="vayesta.lattmod.bethe.hubbard1d_bethe_gap">
<span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.bethe.</span></span><span class="sig-name descname"><span class="pre">hubbard1d_bethe_gap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">100)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/bethe.html#hubbard1d_bethe_gap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.bethe.hubbard1d_bethe_gap" title="Link to this definition"></a></dt>
<dd><p>Exact band gap for the 1D Hubbard model at half filling in the thermodynamic limit.</p>
<p>from DOI: 10.1103/PhysRevB.106.045123</p>
</dd></dl>

</section>
<section id="module-vayesta.lattmod.latt">
<span id="vayesta-lattmod-latt"></span><h2>vayesta.lattmod.latt<a class="headerlink" href="#module-vayesta.lattmod.latt" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.latt.</span></span><span class="sig-name descname"><span class="pre">LatticeMole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsite</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelectron</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incore_anyway</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeMole"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
<p>For PySCF compatibility</p>
<p>Needs to implement:
a
copy()
build()
intor_cross()
intor_symmetric()
pbc_intor()
basis</p>
<p>?
atom_coord
unit</p>
<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.nelectron">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelectron</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.nelectron" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.spin">
<span class="sig-name descname"><span class="pre">spin</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.spin" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.incore_anyway">
<span class="sig-name descname"><span class="pre">incore_anyway</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.incore_anyway" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.natm">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">natm</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.natm" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.nao_nr">
<span class="sig-name descname"><span class="pre">nao_nr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeMole.nao_nr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.nao_nr" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.ao_labels">
<span class="sig-name descname"><span class="pre">ao_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeMole.ao_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.ao_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of AO basis functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>fmt<span class="classifier">str or bool</span></dt><dd><p>if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-AO-notation)]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.atom_symbol">
<span class="sig-name descname"><span class="pre">atom_symbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">site</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeMole.atom_symbol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.atom_symbol" title="Link to this definition"></a></dt>
<dd><p>For the given atom id, return the input symbol (without striping special characters)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H^2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.atom_pure_symbol">
<span class="sig-name descname"><span class="pre">atom_pure_symbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">site</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeMole.atom_pure_symbol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.atom_pure_symbol" title="Link to this definition"></a></dt>
<dd><p>For the given atom id, return the standard symbol (striping special characters)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_pure_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.search_ao_label">
<span class="sig-name descname"><span class="pre">search_ao_label</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeMole.search_ao_label"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.search_ao_label" title="Link to this definition"></a></dt>
<dd><p>Find the index of the AO basis function based on the given ao_label</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ao_label</strong> – string or a list of strings
The regular expression pattern to match the orbital labels
returned by mol.ao_labels()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of index for the AOs that matches the given ao_label RE pattern</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl.*p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21 22 23 24 25 26 27 28 29 30]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl 2p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">([</span><span class="s1">&#39;Cl.*d&#39;</span><span class="p">,</span> <span class="s1">&#39;Cl 4p&#39;</span><span class="p">])</span>
<span class="go">[25 26 27 31 32 33 34 35 36 37 38 39 40]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.Gv">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Gv</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.Gv" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.ao_loc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ao_loc</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.ao_loc" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start basis function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.ao_loc_2c">
<span class="sig-name descname"><span class="pre">ao_loc_2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.ao_loc_2c" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spinor basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start id of spinor function</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_2c</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 2, 4, 6, 12, 18, 20, 22, 24, 30, 36]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.ao_loc_nr">
<span class="sig-name descname"><span class="pre">ao_loc_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.ao_loc_nr" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start basis function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.ao_rotation_matrix">
<span class="sig-name descname"><span class="pre">ao_rotation_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orientation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.ao_rotation_matrix" title="Link to this definition"></a></dt>
<dd><p>Matrix u to rotate AO basis to a new orientation.</p>
<p>atom_new_coords = mol.atom_coords().dot(orientation.T)
new_AO = u * mol.AO
new_orbitals_coef = u.dot(orbitals_coef)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.aoslice_2c_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_2c_by_atom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.aoslice_2c_by_atom" title="Link to this definition"></a></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.aoslice_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.aoslice_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.aoslice_nr_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_nr_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.aoslice_nr_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.apply" title="Link to this definition"></a></dt>
<dd><p>Apply the fn to rest arguments:  return <code class="docutils literal notranslate"><span class="pre">fn(*args,</span> <span class="pre">**kwargs)</span></code>.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.atom_charge">
<span class="sig-name descname"><span class="pre">atom_charge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.atom_charge" title="Link to this definition"></a></dt>
<dd><p>Nuclear effective charge of the given atom id
Note “atom_charge /= charge(atom_symbol)” when ECP is enabled.
Number of electrons screened by ECP can be obtained by charge(atom_symbol)-atom_charge</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">17</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.atom_charges">
<span class="sig-name descname"><span class="pre">atom_charges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.atom_charges" title="Link to this definition"></a></dt>
<dd><p>np.asarray([mol.atom_charge(i) for i in range(mol.natm)])</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.atom_coord">
<span class="sig-name descname"><span class="pre">atom_coord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Bohr'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.atom_coord" title="Link to this definition"></a></dt>
<dd><p>Coordinates (ndarray) of the given atom id</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.atom_coords">
<span class="sig-name descname"><span class="pre">atom_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Bohr'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.atom_coords" title="Link to this definition"></a></dt>
<dd><p>np.asarray([mol.atom_coord(i) for i in range(mol.natm)])</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.atom_mass_list">
<span class="sig-name descname"><span class="pre">atom_mass_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isotope_avg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.atom_mass_list" title="Link to this definition"></a></dt>
<dd><p>A list of mass for all atoms in the molecule</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>isotope_avg<span class="classifier">boolean</span></dt><dd><p>Whether to use the isotope average mass as the atomic mass</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.atom_nelec_core">
<span class="sig-name descname"><span class="pre">atom_nelec_core</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.atom_nelec_core" title="Link to this definition"></a></dt>
<dd><p>Number of core electrons for pseudo potential.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.atom_nshells">
<span class="sig-name descname"><span class="pre">atom_nshells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.atom_nshells" title="Link to this definition"></a></dt>
<dd><p>Number of basis/shells of the given atom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_nshells</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.atom_shell_ids">
<span class="sig-name descname"><span class="pre">atom_shell_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.atom_shell_ids" title="Link to this definition"></a></dt>
<dd><p>A list of the shell-ids of the given atom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_shell_ids</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[3, 4, 5, 6, 7]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_angular">
<span class="sig-name descname"><span class="pre">bas_angular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_angular" title="Link to this definition"></a></dt>
<dd><p>The angular momentum associated with the given basis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_angular</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_atom">
<span class="sig-name descname"><span class="pre">bas_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_atom" title="Link to this definition"></a></dt>
<dd><p>The atom (0-based id) that the given basis sits on</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_coord">
<span class="sig-name descname"><span class="pre">bas_coord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_coord" title="Link to this definition"></a></dt>
<dd><p>Coordinates (ndarray) associated with the given basis id</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_ctr_coeff">
<span class="sig-name descname"><span class="pre">bas_ctr_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_ctr_coeff" title="Link to this definition"></a></dt>
<dd><p>Contract coefficients (ndarray) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_ctr_coeff</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[[ 10.03400444]</span>
<span class="go"> [  4.1188704 ]</span>
<span class="go"> [  1.53971186]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_exp">
<span class="sig-name descname"><span class="pre">bas_exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_exp" title="Link to this definition"></a></dt>
<dd><p>exponents (ndarray) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_exp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[ 13.01     1.962    0.4446]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_exps">
<span class="sig-name descname"><span class="pre">bas_exps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_exps" title="Link to this definition"></a></dt>
<dd><p>exponents of all basis
return [mol.bas_exp(i) for i in range(self.nbas)]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_kappa">
<span class="sig-name descname"><span class="pre">bas_kappa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_kappa" title="Link to this definition"></a></dt>
<dd><p>Kappa (if l &lt; j, -l-1, else l) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_kappa</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_len_cart">
<span class="sig-name descname"><span class="pre">bas_len_cart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_len_cart" title="Link to this definition"></a></dt>
<dd><p>The number of Cartesian function associated with given basis</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_len_spinor">
<span class="sig-name descname"><span class="pre">bas_len_spinor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_len_spinor" title="Link to this definition"></a></dt>
<dd><p>The number of spinor associated with given basis
If kappa is 0, return 4l+2</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_nctr">
<span class="sig-name descname"><span class="pre">bas_nctr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_nctr" title="Link to this definition"></a></dt>
<dd><p>The number of contracted GTOs for the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_nctr</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_nprim">
<span class="sig-name descname"><span class="pre">bas_nprim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_nprim" title="Link to this definition"></a></dt>
<dd><p>The number of primitive GTOs for the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_nprim</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.bas_rcut">
<span class="sig-name descname"><span class="pre">bas_rcut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.bas_rcut" title="Link to this definition"></a></dt>
<dd><p>Estimate the largest distance between the function and its image to
reach the precision in overlap</p>
<p>precision ~ int g(r-0) g(r-Rcut)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dump_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parse_arg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_dim_ft_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmorphic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_loose_rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_particle_mesh_ewald</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fractional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.build" title="Link to this definition"></a></dt>
<dd><p>Setup Mole molecule and Cell and initialize some control parameters.
Whenever you change the value of the attributes of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code>,
you need call this function to refresh the internal data of Cell.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>a<span class="classifier">(3,3) ndarray</span></dt><dd><p>The real-space cell lattice vectors. Each row represents
a lattice vector.</p>
</dd>
<dt>fractional<span class="classifier">bool</span></dt><dd><p>Whether the atom postions are specified in fractional coordinates.
The default value is False, which means the coordinates are
interpreted as Cartesian coordinate.</p>
</dd>
<dt>mesh<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>The number of <em>positive</em> G-vectors along each direction.</p>
</dd>
<dt>ke_cutoff<span class="classifier">float</span></dt><dd><p>If set, defines a spherical cutoff of planewaves, with .5 * G**2 &lt; ke_cutoff
The default value is estimated based on <a class="reference internal" href="#vayesta.lattmod.latt.LatticeMole.precision" title="vayesta.lattmod.latt.LatticeMole.precision"><code class="xref py py-attr docutils literal notranslate"><span class="pre">precision</span></code></a></p>
</dd>
<dt>precision<span class="classifier">float</span></dt><dd><p>To control Ewald sums and lattice sums accuracy</p>
</dd>
<dt>nimgs<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>Number of repeated images in lattice summation to produce
periodicity. This value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>rcut<span class="classifier">float</span></dt><dd><p>Cutoff radius (unit Bohr) in lattice summation to produce
periodicity. The value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>h<span class="classifier">(3,3) ndarray</span></dt><dd><p>a.T. Deprecated</p>
</dd>
<dt>dimension<span class="classifier">int</span></dt><dd><p>Default is 3</p>
</dd>
<dt>low_dim_ft_type<span class="classifier">str</span></dt><dd><p>For semi-empirical periodic systems, whether to calculate
integrals at the non-PBC dimension using the sampled mesh grids in
infinity vacuum (inf_vacuum) or truncated Coulomb potential
(analytic_2d_1). Unless explicitly specified, analytic_2d_1 is
used for 2D system and inf_vacuum is assumed for 1D and 0D.</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry. Default is False.</p>
</dd>
<dt>symmorphic<span class="classifier">bool</span></dt><dd><p>Whether the lattice is symmorphic. If set to True, even if the
lattice is non-symmorphic, only symmorphic space group symmetry
will be considered. Default is False, meaning the space group is
determined by the lattice symmetry to be symmorphic or non-symmorphic.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.build_lattice_symmetry">
<span class="sig-name descname"><span class="pre">build_lattice_symmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">check_mesh_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.build_lattice_symmetry" title="Link to this definition"></a></dt>
<dd><p>Build cell.lattice_symmetry object.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>check_mesh_symmetry<span class="classifier">bool</span></dt><dd><p>For nonsymmorphic symmetry groups, <cite>cell.mesh</cite> may have
lower symmetry than the lattice. In this case, if
<cite>check_mesh_symmetry</cite> is <cite>True</cite>, the lower symmetry group will
be used. Otherwise, if <cite>check_mesh_symmetry</cite> is <cite>False</cite>,
the mesh grid will be modified to satisfy the higher symmetry.
Default value is <cite>True</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function modifies the attributes of <cite>cell</cite>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.cart">
<span class="sig-name descname"><span class="pre">cart</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.cart" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.cart2sph_coeff">
<span class="sig-name descname"><span class="pre">cart2sph_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sp'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.cart2sph_coeff" title="Link to this definition"></a></dt>
<dd><p>Transformation matrix that transforms Cartesian GTOs to spherical
GTOs for all basis functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>normalized<span class="classifier">string or boolean</span></dt><dd><p>How the Cartesian GTOs are normalized.  Except s and p functions,
Cartesian GTOs do not have the universal normalization coefficients
for the different components of the same shell.  The value of this
argument can be one of ‘sp’, ‘all’, None.  ‘sp’ means the Cartesian s
and p basis are normalized.  ‘all’ means all Cartesian functions are
normalized.  None means none of the Cartesian functions are normalized.
The default value ‘sp’ is the convention used by libcint library.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">cart2sph_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_cart&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">4.58676826646e-15</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.cart_labels">
<span class="sig-name descname"><span class="pre">cart_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.cart_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of Cartesian GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-xyz-notation)]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.charge">
<span class="sig-name descname"><span class="pre">charge</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.charge" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.check_sanity">
<span class="sig-name descname"><span class="pre">check_sanity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.check_sanity" title="Link to this definition"></a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.condense_to_shell">
<span class="sig-name descname"><span class="pre">condense_to_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compressor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'max'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.condense_to_shell" title="Link to this definition"></a></dt>
<dd><p>The given matrix is first partitioned to blocks, based on AO shell as
delimiter. Then call compressor function to abstract each block.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>compressor</strong> – string or function
if compressor is a string, its value can be  sum, max, min, abssum,
absmax, absmin, norm</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.copy" title="Link to this definition"></a></dt>
<dd><p>Deepcopy of the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
<p>Some attributes are shared between the original and copied objects.
Deepcopy is utilized here to ensure that operations on the copied object do
not affect the original object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.cutoff_to_mesh">
<span class="sig-name descname"><span class="pre">cutoff_to_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.cutoff_to_mesh" title="Link to this definition"></a></dt>
<dd><p>Convert KE cutoff to FFT-mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ke_cutoff</strong> – float
KE energy cutoff in a.u.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(3,) array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.decontract_basis">
<span class="sig-name descname"><span class="pre">decontract_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.decontract_basis" title="Link to this definition"></a></dt>
<dd><p>Decontract the basis of a Mole or a Cell.  Returns a Mole (Cell) object
with the uncontracted basis environment and a list of coefficients that
transform the uncontracted basis to the original basis. Each element in
the coefficients list corresponds to one shell of the original Mole (Cell).</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>atoms: list or str</dt><dd><p>Atoms on which the basis to be decontracted. By default, all basis
are decontracted</p>
</dd>
<dt>to_cart: bool</dt><dd><p>Decontract basis and transfer to Cartesian basis</p>
</dd>
<dt>aggregate: bool</dt><dd><p>Whether to aggregate the transformation coefficients into a giant
transformation matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Ne&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmol</span><span class="p">,</span> <span class="n">ctr_coeff</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">decontract_basis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">ctr_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.dimension">
<span class="sig-name descname"><span class="pre">dimension</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.dimension" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.drop_exponent">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">drop_exponent</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.drop_exponent" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.dump_input">
<span class="sig-name descname"><span class="pre">dump_input</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.dump_input" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.dumps">
<span class="sig-name descname"><span class="pre">dumps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.dumps" title="Link to this definition"></a></dt>
<dd><p>Serialize Cell object to a JSON formatted str.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.elements">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">elements</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.elements" title="Link to this definition"></a></dt>
<dd><p>A list of elements in the molecule</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.energy_nuc">
<span class="sig-name descname"><span class="pre">energy_nuc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.energy_nuc" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.enuc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enuc</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.enuc" title="Link to this definition"></a></dt>
<dd><p>nuclear repulsion energy</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.etbs">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">etbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">etbs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.etbs" title="Link to this definition"></a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#vayesta.lattmod.latt.LatticeMole.expand_etb" title="vayesta.lattmod.latt.LatticeMole.expand_etb"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand_etb()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[</strong> (<em>etbs =</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.eval_ao">
<span class="sig-name descname"><span class="pre">eval_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.eval_ao" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.eval_gto">
<span class="sig-name descname"><span class="pre">eval_gto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.eval_gto" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.ew_cut">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ew_cut</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.ew_cut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.ew_eta">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ew_eta</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.ew_eta" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.ewald">
<span class="sig-name descname"><span class="pre">ewald</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.ewald" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.exp_to_discard">
<span class="sig-name descname"><span class="pre">exp_to_discard</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.exp_to_discard" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.expand_etb">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">expand_etb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.expand_etb" title="Link to this definition"></a></dt>
<dd><p>Generate the exponents of even tempered basis for <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code>.
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span>\<span class="n">alpha</span> <span class="o">*</span> \<span class="n">beta</span><span class="o">^</span><span class="p">{</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">}}</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">..</span> <span class="n">n</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l</strong> – int
Angular momentum</p></li>
<li><p><strong>n</strong> – int
Number of GTOs</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[1, [6.0, 1]], [1, [3.0, 1]], [1, [1.5, 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.expand_etbs">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">expand_etbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">etbs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.expand_etbs" title="Link to this definition"></a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#vayesta.lattmod.latt.LatticeMole.expand_etb" title="vayesta.lattmod.latt.LatticeMole.expand_etb"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand_etb()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[</strong> (<em>etbs =</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.format_atom">
<span class="sig-name descname"><span class="pre">format_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'angstrom'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.format_atom" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.atom</span></code> to the internal data format.
Including, changing the nuclear charge to atom symbol, converting the
coordinates to AU, rotate and shift the molecule.
If the <code class="xref py py-attr docutils literal notranslate"><span class="pre">atom</span></code> is a string, it takes “;” and “n”
for the mark to separate atoms;  “,” and arbitrary length of blank space
to separate the individual terms for an atom.  Blank line will be ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atoms</strong> – list or str
the same to <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.atom</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>origin<span class="classifier">ndarray</span></dt><dd><p>new axis origin.</p>
</dd>
<dt>axes<span class="classifier">ndarray</span></dt><dd><p>(new_x, new_y, new_z), new coordinates</p>
</dd>
<dt>unit<span class="classifier">str or number</span></dt><dd><p>If unit is one of strings (B, b, Bohr, bohr, AU, au), the coordinates
of the input atoms are the atomic unit;  If unit is one of strings
(A, a, Angstrom, angstrom, Ang, ang), the coordinates are in the
unit of angstrom;  If a number is given, the number are considered
as the Bohr value (in angstrom), which should be around 0.53.
Set unit=1 if wishing to preserve the unit of the coordinates.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl>
<dt>“atoms” in the internal format. The internal format is</dt><dd><div class="line-block">
<div class="line">atom = [[atom1, (x, y, z)],</div>
<div class="line-block">
<div class="line">[atom2, (x, y, z)],</div>
<div class="line">…</div>
<div class="line">[atomN, (x, y, z)]]</div>
</div>
</div>
</dd>
</dl>
</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">(</span><span class="s1">&#39;9,0,0,0; h@1 0 0 1&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H@1&#39;, [-1.0, -1.0, 0.0]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">([</span><span class="s1">&#39;9,0,0,0&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))],</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H&#39;, [-1, -1, 0]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.format_basis">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_tab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.format_basis" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code> to the internal data format.</p>
<dl>
<dt><a href="#id1"><span class="problematic" id="id2">``</span></a>{ atom: [(l, ((-exp, c_1, c_2, ..),</dt><dd><blockquote>
<div><p>(-exp, c_1, c_2, ..))),</p>
</div></blockquote>
<dl class="simple">
<dt>(l, ((-exp, c_1, c_2, ..),</dt><dd><p>(-exp, c_1, c_2, ..)))], … }``</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>basis_tab</strong> – dict
Similar to <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code>, it <strong>cannot</strong> be a str</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="s1">&#39;H^2&#39;</span><span class="p">:</span> <span class="s1">&#39;3-21g&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    [3.4252509099999999, 0.15432897000000001],</span>
<span class="go">    [0.62391373000000006, 0.53532813999999995],</span>
<span class="go">    [0.16885539999999999, 0.44463454000000002]]],</span>
<span class="go"> &#39;H^2&#39;: [[0,</span>
<span class="go">    [5.4471780000000001, 0.15628500000000001],</span>
<span class="go">    [0.82454700000000003, 0.90469100000000002]],</span>
<span class="go">    [0, [0.18319199999999999, 1.0]]]}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;gth-szv&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    (8.3744350009, -0.0283380461),</span>
<span class="go">    (1.8058681460, -0.1333810052),</span>
<span class="go">    (0.4852528328, -0.3995676063),</span>
<span class="go">    (0.1658236932, -0.5531027541)]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.format_ecp">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_ecp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ecp_tab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.format_ecp" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">ecp</span></code> (dict) to the internal data format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span><span class="n">nelec</span><span class="p">,</span>  <span class="c1"># core electrons</span>
</pre></div>
</div>
<blockquote>
<div><blockquote>
<div><dl>
<dt>((l,  # l=-1 for UL, l&gt;=0 for Ul to indicate <a href="#id22"><span class="problematic" id="id23">|l&gt;&lt;l|</span></a></dt><dd><dl>
<dt>(((exp_1, c_1),  # for r^0</dt><dd><blockquote>
<div><p>(exp_2, c_2),
…),</p>
</div></blockquote>
<dl class="simple">
<dt>((exp_1, c_1),  # for r^1</dt><dd><p>(exp_2, c_2),
…),</p>
</dd>
<dt>((exp_1, c_1),  # for r^2</dt><dd><p>…))))),</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>…}</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.format_pseudo">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_pseudo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pseudo_tab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.format_pseudo" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code> (dict) to the internal data format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span> <span class="p">(</span><span class="n">nelec_s</span><span class="p">,</span> <span class="n">nele_p</span><span class="p">,</span> <span class="n">nelec_d</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>
         <span class="n">rloc</span><span class="p">,</span> <span class="n">nexp</span><span class="p">,</span> <span class="p">(</span><span class="n">cexp_1</span><span class="p">,</span> <span class="n">cexp_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">cexp_nexp</span><span class="p">),</span>
         <span class="n">nproj_types</span><span class="p">,</span>
         <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">nproj1</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
                        <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
                        <span class="o">...</span>
                        <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="n">nproj1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="n">nproj1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span>        <span class="p">)</span> <span class="p">)),</span>
         <span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">nproj2</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
         <span class="o">...</span> <span class="p">)</span> <span class="p">)</span>
         <span class="p">)</span>
 <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pseudo_tab</strong> – dict
Similar to <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code> (a dict), it <strong>cannot</strong> be a str</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pbc</span><span class="o">.</span><span class="n">format_pseudo</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;gth-blyp&#39;</span><span class="p">,</span> <span class="s1">&#39;He&#39;</span><span class="p">:</span> <span class="s1">&#39;gth-pade&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[1],</span>
<span class="go">    0.2, 2, [-4.19596147, 0.73049821], 0],</span>
<span class="go"> &#39;He&#39;: [[2],</span>
<span class="go">    0.2, 2, [-9.1120234, 1.69836797], 0]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.fractional">
<span class="sig-name descname"><span class="pre">fractional</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.fractional" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.from_ase">
<span class="sig-name descname"><span class="pre">from_ase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ase_atom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.from_ase" title="Link to this definition"></a></dt>
<dd><p>Update cell based on given ase atom object</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ase.lattice</span><span class="w"> </span><span class="kn">import</span> <span class="n">bulk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">from_ase</span><span class="p">(</span><span class="n">bulk</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">LATTICE_CONST</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.fromfile">
<span class="sig-name descname"><span class="pre">fromfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.fromfile" title="Link to this definition"></a></dt>
<dd><p>Update the Cell object based on the input geometry file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.fromstring">
<span class="sig-name descname"><span class="pre">fromstring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'poscar'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.fromstring" title="Link to this definition"></a></dt>
<dd><p>Update the Cell object based on the input geometry string</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.gen_uniform_grids">
<span class="sig-name descname"><span class="pre">gen_uniform_grids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.gen_uniform_grids" title="Link to this definition"></a></dt>
<dd><p>Generate a uniform real-space grid consistent w/ samp thm; see MH (3.19).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngx*ngy*ngz, 3) ndarray</dt><dd><p>The real-space grid point coordinates.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>coords</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_Gv">
<span class="sig-name descname"><span class="pre">get_Gv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_Gv" title="Link to this definition"></a></dt>
<dd><p>Calculate three-dimensional G-vectors for the cell; see MH (3.8).</p>
<p>Indices along each direction go as [0…N-1, -N…-1] to follow FFT convention.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngrids, 3) ndarray of floats</dt><dd><p>The array of G-vectors.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Gv</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_Gv_weights">
<span class="sig-name descname"><span class="pre">get_Gv_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_Gv_weights" title="Link to this definition"></a></dt>
<dd><p>Calculate G-vectors and weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>(ngris, 3) ndarray of floats</dt><dd><p>The array of G-vectors.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Gv</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_SI">
<span class="sig-name descname"><span class="pre">get_SI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Gv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmlst</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_SI" title="Link to this definition"></a></dt>
<dd><p>Calculate the structure factor (0D, 1D, 2D, 3D) for all atoms; see MH (3.34).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p></li>
<li><p><strong>Gv</strong> – (N,3) array
G vectors</p></li>
<li><p><strong>atmlst</strong> – list of ints, optional
Indices of atoms for which the structure factors are computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(natm, ngrids) ndarray, dtype=np.complex128</dt><dd><p>The structure factor for each atom at each G-vector.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SI</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_abs_kpts">
<span class="sig-name descname"><span class="pre">get_abs_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scaled_kpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_abs_kpts" title="Link to this definition"></a></dt>
<dd><p>Get absolute k-points (in 1/Bohr), given “scaled” k-points in
fractions of lattice vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>scaled_kpts</strong> – (nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>abs_kpts</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_ao_indices">
<span class="sig-name descname"><span class="pre">get_ao_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_ao_indices" title="Link to this definition"></a></dt>
<dd><p>Generate (dis-continued) AO indices for basis specified in bas_list</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_bounding_sphere">
<span class="sig-name descname"><span class="pre">get_bounding_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rcut</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_bounding_sphere" title="Link to this definition"></a></dt>
<dd><p>Finds all the lattice points within a sphere of radius rcut.</p>
<p>Defines a parallelepiped given by -N_x &lt;= n_x &lt;= N_x, with x in [1,3]
See Martin p. 85</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rcut</strong> – number
real space cut-off for interaction</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray of 3 ints defining N_x</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>cut</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_enuc">
<span class="sig-name descname"><span class="pre">get_enuc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_enuc" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_ewald_params">
<span class="sig-name descname"><span class="pre">get_ewald_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_ewald_params" title="Link to this definition"></a></dt>
<dd><p>Choose a reasonable value of Ewald ‘eta’ and ‘cut’ parameters.
eta^2 is the exponent coefficient of the model Gaussian charge for nucleus
at R:  frac{eta^3}{pi^1.5} e^{-eta^2 (r-R)^2}</p>
<p>Choice is based on largest G vector and desired relative precision.</p>
<p>The relative error in the G-space sum is given by</p>
<blockquote>
<div><p>precision ~ 4pi Gmax^2 e^{(-Gmax^2)/(4 eta^2)}</p>
</div></blockquote>
<p>which determines eta. Then, real-space cutoff is determined by (exp.
factors only)</p>
<blockquote>
<div><p>precision ~ erfc(eta*rcut) / rcut ~ e^{(-eta**2 rcut*2)}</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald ‘eta’ and ‘cut’ parameters.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ew_eta, ew_cut</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_kpts">
<span class="sig-name descname"><span class="pre">get_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_gamma_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_reversal_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_kpts" title="Link to this definition"></a></dt>
<dd><p>Given number of kpoints along x,y,z , generate kpoints</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nks</strong> – (3,) ndarray</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>wrap_around<span class="classifier">bool</span></dt><dd><p>To ensure all kpts are in first Brillouin zone.</p>
</dd>
<dt>with_gamma_point<span class="classifier">bool</span></dt><dd><p>Whether to shift Monkhorst-pack grid to include gamma-point.</p>
</dd>
<dt>scaled_center<span class="classifier">(3,) array</span></dt><dd><p>Shift all points in the Monkhorst-pack grid to be centered on
scaled_center, given as the zeroth index of the returned kpts.
Scaled meaning that the k-points are scaled to a grid from
[-1,1] x [-1,1] x [-1,1]</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry</p>
</dd>
<dt>time_reversal_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider time reversal symmetry</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>kpts in absolute value (unit 1/Bohr).  Gamma point is placed at the
first place in the k-points list;
instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> if k-point symmetry is considered</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_lattice_Ls">
<span class="sig-name descname"><span class="pre">get_lattice_Ls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_lattice_Ls" title="Link to this definition"></a></dt>
<dd><p>Get the (Cartesian, unitful) lattice translation vectors for nearby images.
The translation vectors can be used for the lattice summation.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>discard:</dt><dd><p>Drop less important Ls based on AO values on grid</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_nimgs">
<span class="sig-name descname"><span class="pre">get_nimgs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_nimgs" title="Link to this definition"></a></dt>
<dd><p>Choose number of basis function images in lattice sums
to include for given precision in overlap, using</p>
<p>precision ~ int r^l e^{-alpha r^2} (r-rcut)^l e^{-alpha (r-rcut)^2}
~ (rcut^2/(2alpha))^l e^{alpha/2 rcut^2}</p>
<p>where alpha is the smallest exponent in the basis. Note
that assumes an isolated exponent in the middle of the box, so
it adds one additional lattice vector to be safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_overlap_cond">
<span class="sig-name descname"><span class="pre">get_overlap_cond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_overlap_cond" title="Link to this definition"></a></dt>
<dd><p>Overlap magnitudes measured by -log(overlap) between two shells</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>2D mask array of shape (nbas,nbas)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_scaled_atom_coords">
<span class="sig-name descname"><span class="pre">get_scaled_atom_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_scaled_atom_coords" title="Link to this definition"></a></dt>
<dd><p>Get scaled atomic coordinates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_scaled_kpts">
<span class="sig-name descname"><span class="pre">get_scaled_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">abs_kpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts_in_ibz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_scaled_kpts" title="Link to this definition"></a></dt>
<dd><p>Get scaled k-points, given absolute k-points in 1/Bohr.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>abs_kpts</strong> – (nkpts, 3) ndarray of floats or <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> object</p></li>
<li><p><strong>kpts_in_ibz</strong> – bool
If True, return k-points in IBZ; otherwise, return k-points in BZ.
Default value is True. This has effects only if abs_kpts is a
<code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>scaled_kpts</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.get_uniform_grids">
<span class="sig-name descname"><span class="pre">get_uniform_grids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.get_uniform_grids" title="Link to this definition"></a></dt>
<dd><p>Generate a uniform real-space grid consistent w/ samp thm; see MH (3.19).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngx*ngy*ngz, 3) ndarray</dt><dd><p>The real-space grid point coordinates.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>coords</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.gs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gs</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.gs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.gto_norm">
<span class="sig-name descname"><span class="pre">gto_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expnt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.gto_norm" title="Link to this definition"></a></dt>
<dd><p>Normalized factor for GTO radial part   <span class="math notranslate nohighlight">\(g=r^l e^{-\alpha r^2}\)</span></p>
<div class="math notranslate nohighlight">
\[\frac{1}{\sqrt{\int g^2 r^2 dr}}
= \sqrt{\frac{2^{2l+3} (l+1)! (2a)^{l+1.5}}{(2l+2)!\sqrt{\pi}}}\]</div>
<p>Ref: H. B. Schlegel and M. J. Frisch, Int. J. Quant.  Chem., 54(1995), 83-87.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l</strong> (<em>int</em>) – angular momentum</p></li>
<li><p><strong>expnt</strong> – exponent <span class="math notranslate nohighlight">\(\alpha\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>normalization factor</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gto_norm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">2.5264751109842591</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.h">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">h</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.h" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.has_ecp">
<span class="sig-name descname"><span class="pre">has_ecp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.has_ecp" title="Link to this definition"></a></dt>
<dd><p>Whether pseudo potential is used in the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.has_ecp_soc">
<span class="sig-name descname"><span class="pre">has_ecp_soc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.has_ecp_soc" title="Link to this definition"></a></dt>
<dd><p>Whether spin-orbit coupling is enabled in ECP.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.intor">
<span class="sig-name descname"><span class="pre">intor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s1'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.intor" title="Link to this definition"></a></dt>
<dd><p>Integral generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1e or 2e AO integrals.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Symmetry of the integrals</p>
<div class="line-block">
<div class="line">0 : no symmetry assumed (default)</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>shls_slice<span class="classifier">4-element, 6-element or 8-element tuple</span></dt><dd><p>Label the start-stop shells for each index in the integral.
For example, the 8-element tuple for the 2-electron integral
tensor (ij|kl) = intor(‘int2e’) are specified as
(ish_start, ish_end, jsh_start, jsh_end, ksh_start, ksh_end, lsh_start, lsh_end)</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ipnuc_sph&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># &lt;nabla i | V_nuc | j&gt;</span>
<span class="go">[[[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.10289944  0.48176097]</span>
<span class="go">  [-0.48176097 -0.10289944]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.intor_asymmetric">
<span class="sig-name descname"><span class="pre">intor_asymmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.intor_asymmetric" title="Link to this definition"></a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be anti-hermitian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp has 3 components.</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_asymmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j  0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j  0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.intor_by_shell">
<span class="sig-name descname"><span class="pre">intor_by_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.intor_by_shell" title="Link to this definition"></a></dt>
<dd><p>For given 2, 3 or 4 shells, interface for libcint to get 1e, 2e,
2-center-2e or 3-center-2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>intor_name</strong> – str
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the supported intor_name</p></li>
<li><p><strong>shls</strong> – list of int
The AO shell-ids of the integrals</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp has 3 components.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 2-dim to 5-dim, depending on the integral type (1e,
2e, 3c-2e, 2c2e) and the value of comp</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The gradients of the spherical 2e integrals</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">getints_by_shell</span><span class="p">(</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[[[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.08760462]]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.intor_symmetric">
<span class="sig-name descname"><span class="pre">intor_symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.intor_symmetric" title="Link to this definition"></a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be hermitian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_symmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.kernel">
<span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dump_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parse_arg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_dim_ft_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmorphic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_loose_rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_particle_mesh_ewald</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fractional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.kernel" title="Link to this definition"></a></dt>
<dd><p>Setup Mole molecule and Cell and initialize some control parameters.
Whenever you change the value of the attributes of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code>,
you need call this function to refresh the internal data of Cell.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>a<span class="classifier">(3,3) ndarray</span></dt><dd><p>The real-space cell lattice vectors. Each row represents
a lattice vector.</p>
</dd>
<dt>fractional<span class="classifier">bool</span></dt><dd><p>Whether the atom postions are specified in fractional coordinates.
The default value is False, which means the coordinates are
interpreted as Cartesian coordinate.</p>
</dd>
<dt>mesh<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>The number of <em>positive</em> G-vectors along each direction.</p>
</dd>
<dt>ke_cutoff<span class="classifier">float</span></dt><dd><p>If set, defines a spherical cutoff of planewaves, with .5 * G**2 &lt; ke_cutoff
The default value is estimated based on <a class="reference internal" href="#vayesta.lattmod.latt.LatticeMole.precision" title="vayesta.lattmod.latt.LatticeMole.precision"><code class="xref py py-attr docutils literal notranslate"><span class="pre">precision</span></code></a></p>
</dd>
<dt>precision<span class="classifier">float</span></dt><dd><p>To control Ewald sums and lattice sums accuracy</p>
</dd>
<dt>nimgs<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>Number of repeated images in lattice summation to produce
periodicity. This value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>rcut<span class="classifier">float</span></dt><dd><p>Cutoff radius (unit Bohr) in lattice summation to produce
periodicity. The value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>h<span class="classifier">(3,3) ndarray</span></dt><dd><p>a.T. Deprecated</p>
</dd>
<dt>dimension<span class="classifier">int</span></dt><dd><p>Default is 3</p>
</dd>
<dt>low_dim_ft_type<span class="classifier">str</span></dt><dd><p>For semi-empirical periodic systems, whether to calculate
integrals at the non-PBC dimension using the sampled mesh grids in
infinity vacuum (inf_vacuum) or truncated Coulomb potential
(analytic_2d_1). Unless explicitly specified, analytic_2d_1 is
used for 2D system and inf_vacuum is assumed for 1D and 0D.</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry. Default is False.</p>
</dd>
<dt>symmorphic<span class="classifier">bool</span></dt><dd><p>Whether the lattice is symmorphic. If set to True, even if the
lattice is non-symmorphic, only symmorphic space group symmetry
will be considered. Default is False, meaning the space group is
determined by the lattice symmetry to be symmorphic or non-symmorphic.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.lattice_symmetry">
<span class="sig-name descname"><span class="pre">lattice_symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.lattice_symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.lattice_vectors">
<span class="sig-name descname"><span class="pre">lattice_vectors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.lattice_vectors" title="Link to this definition"></a></dt>
<dd><p>Convert the primitive lattice vectors.</p>
<p>Return 3x3 array in which each row represents one direction of the
lattice vectors (unit in Bohr)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.loads">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molstr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.loads" title="Link to this definition"></a></dt>
<dd><p>Deserialize a str containing a JSON document to a Cell object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.loads_">
<span class="sig-name descname"><span class="pre">loads_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molstr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.loads_" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.low_dim_ft_type">
<span class="sig-name descname"><span class="pre">low_dim_ft_type</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.low_dim_ft_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.make_atm_env">
<span class="sig-name descname"><span class="pre">make_atm_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucmod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucprop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.make_atm_env" title="Link to this definition"></a></dt>
<dd><p>Convert the internal format <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._atom</span></code> to the format required
by <code class="docutils literal notranslate"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.make_bas_env">
<span class="sig-name descname"><span class="pre">make_bas_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_add</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.make_bas_env" title="Link to this definition"></a></dt>
<dd><p>Convert <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code> to the argument <code class="docutils literal notranslate"><span class="pre">bas</span></code> for <code class="docutils literal notranslate"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.make_ecp_env">
<span class="sig-name descname"><span class="pre">make_ecp_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_atm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_ecp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.make_ecp_env" title="Link to this definition"></a></dt>
<dd><p>Generate the input arguments _ecpbas for ECP integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.make_env">
<span class="sig-name descname"><span class="pre">make_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucmod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucprop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.make_env" title="Link to this definition"></a></dt>
<dd><p>Generate the input arguments for <code class="docutils literal notranslate"><span class="pre">libcint</span></code> library based on internal
format <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._atom</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._basis</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.make_kpts">
<span class="sig-name descname"><span class="pre">make_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_gamma_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_reversal_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.make_kpts" title="Link to this definition"></a></dt>
<dd><p>Given number of kpoints along x,y,z , generate kpoints</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nks</strong> – (3,) ndarray</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>wrap_around<span class="classifier">bool</span></dt><dd><p>To ensure all kpts are in first Brillouin zone.</p>
</dd>
<dt>with_gamma_point<span class="classifier">bool</span></dt><dd><p>Whether to shift Monkhorst-pack grid to include gamma-point.</p>
</dd>
<dt>scaled_center<span class="classifier">(3,) array</span></dt><dd><p>Shift all points in the Monkhorst-pack grid to be centered on
scaled_center, given as the zeroth index of the returned kpts.
Scaled meaning that the k-points are scaled to a grid from
[-1,1] x [-1,1] x [-1,1]</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry</p>
</dd>
<dt>time_reversal_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider time reversal symmetry</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>kpts in absolute value (unit 1/Bohr).  Gamma point is placed at the
first place in the k-points list;
instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> if k-point symmetry is considered</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.max_memory">
<span class="sig-name descname"><span class="pre">max_memory</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4000</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.max_memory" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.mesh">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mesh</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.mesh" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.ms">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ms</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.ms" title="Link to this definition"></a></dt>
<dd><p>Spin quantum number. multiplicity = ms*2+1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.multiplicity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">multiplicity</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.multiplicity" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.nao">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nao</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.nao" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.nao_2c">
<span class="sig-name descname"><span class="pre">nao_2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.nao_2c" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted spinor GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.nao_2c_range">
<span class="sig-name descname"><span class="pre">nao_2c_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bas_id1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.nao_2c_range" title="Link to this definition"></a></dt>
<dd><p>Lower and upper boundary of contracted spinor basis functions associated
with the given shell range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p></li>
<li><p><strong>bas_id0</strong> – int
start shell id, 0-based</p></li>
<li><p><strong>bas_id1</strong> – int
stop shell id, 0-based</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple of start basis function id and the stop function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_2c_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(4, 12)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.nao_cart">
<span class="sig-name descname"><span class="pre">nao_cart</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.nao_cart" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted cartesian GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.nao_nr_range">
<span class="sig-name descname"><span class="pre">nao_nr_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bas_id1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.nao_nr_range" title="Link to this definition"></a></dt>
<dd><p>Lower and upper boundary of contracted spherical basis functions associated
with the given shell range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p></li>
<li><p><strong>bas_id0</strong> – int
start shell id</p></li>
<li><p><strong>bas_id1</strong> – int
stop shell id</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple of start basis function id and the stop function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_nr_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(2, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.nbas">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nbas</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.nbas" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.nelec">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.nelec" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.nimgs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nimgs</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.nimgs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.npgto_nr">
<span class="sig-name descname"><span class="pre">npgto_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.npgto_nr" title="Link to this definition"></a></dt>
<dd><p>Total number of primitive spherical GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.offset_2c_by_atom">
<span class="sig-name descname"><span class="pre">offset_2c_by_atom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.offset_2c_by_atom" title="Link to this definition"></a></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.offset_ao_by_atom">
<span class="sig-name descname"><span class="pre">offset_ao_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.offset_ao_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.offset_nr_by_atom">
<span class="sig-name descname"><span class="pre">offset_nr_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.offset_nr_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.omega">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">omega</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.omega" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.output">
<span class="sig-name descname"><span class="pre">output</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.output" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.pack">
<span class="sig-name descname"><span class="pre">pack</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.pack" title="Link to this definition"></a></dt>
<dd><p>Pack the input args of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> to a dict, which can be serialized
with <code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.pbc_eval_ao">
<span class="sig-name descname"><span class="pre">pbc_eval_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.pbc_eval_ao" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.pbc_eval_gto">
<span class="sig-name descname"><span class="pre">pbc_eval_gto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.pbc_eval_gto" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.pbc_intor">
<span class="sig-name descname"><span class="pre">pbc_intor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.pbc_intor" title="Link to this definition"></a></dt>
<dd><p>One-electron integrals with PBC.</p>
<div class="math notranslate nohighlight">
\[\sum_T \int \mu(r) * [intor] * \nu (r-T) dr\]</div>
<p>See also Mole.intor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.post_kernel">
<span class="sig-name descname"><span class="pre">post_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.post_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run after the main body of the kernel function.  Internal
variables are exposed to post_kernel through the “envs” dictionary.
Return value of post_kernel function is not required.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.pre_kernel">
<span class="sig-name descname"><span class="pre">pre_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.pre_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run before the main body of kernel function is executed.
Internal variables are exposed to pre_kernel through the “envs”
dictionary.  Return value of pre_kernel function is not required.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.precision">
<span class="sig-name descname"><span class="pre">precision</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-08</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.precision" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.rcut">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rcut</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.rcut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.rcut_by_shells">
<span class="sig-name descname"><span class="pre">rcut_by_shells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_pgf_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.rcut_by_shells" title="Link to this definition"></a></dt>
<dd><p>Compute shell and primitive gaussian function radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.reciprocal_vectors">
<span class="sig-name descname"><span class="pre">reciprocal_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.283185307179586</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.reciprocal_vectors" title="Link to this definition"></a></dt>
<dd><div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\mathbf{b_1} &amp;= 2\pi \frac{\mathbf{a_2} \times \mathbf{a_3}}{\mathbf{a_1} \cdot (\mathbf{a_2} \times \mathbf{a_3})} \\
\mathbf{b_2} &amp;= 2\pi \frac{\mathbf{a_3} \times \mathbf{a_1}}{\mathbf{a_2} \cdot (\mathbf{a_3} \times \mathbf{a_1})} \\
\mathbf{b_3} &amp;= 2\pi \frac{\mathbf{a_1} \times \mathbf{a_2}}{\mathbf{a_3} \cdot (\mathbf{a_1} \times \mathbf{a_2})}
\end{align}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.reset" title="Link to this definition"></a></dt>
<dd><p>Clean up intermediates</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.run" title="Link to this definition"></a></dt>
<dd><p>Call the kernel function of current object.  <cite>args</cite> will be passed
to kernel function.  <cite>kwargs</cite> will be used to update the attributes of
current object.  The return value of method run is the object itself.
This allows a series of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.search_ao_nr">
<span class="sig-name descname"><span class="pre">search_ao_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmshell</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.search_ao_nr" title="Link to this definition"></a></dt>
<dd><p>Search the first basis function id (<strong>not</strong> the shell id) which matches
the given atom-id, angular momentum magnetic angular momentum, principal shell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atm_id</strong> – int
atom id, 0-based</p></li>
<li><p><strong>l</strong> – int
angular momentum</p></li>
<li><p><strong>m</strong> – int
magnetic angular momentum</p></li>
<li><p><strong>atmshell</strong> – int
principal quantum number</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>basis function id, 0-based.  If not found, return None</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_nr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Cl 3px</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.search_ao_r">
<span class="sig-name descname"><span class="pre">search_ao_r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmshell</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.search_ao_r" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.search_shell_id">
<span class="sig-name descname"><span class="pre">search_shell_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.search_shell_id" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set" title="Link to this definition"></a></dt>
<dd><p>Update the attributes of the current object.  The return value of
method set is the object itself.  This allows a series of
functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_common_orig">
<span class="sig-name descname"><span class="pre">set_common_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_common_orig" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_common_orig_">
<span class="sig-name descname"><span class="pre">set_common_orig_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_common_orig_" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_common_origin">
<span class="sig-name descname"><span class="pre">set_common_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_common_origin" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_common_origin_">
<span class="sig-name descname"><span class="pre">set_common_origin_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_common_origin_" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_f12_zeta">
<span class="sig-name descname"><span class="pre">set_f12_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_f12_zeta" title="Link to this definition"></a></dt>
<dd><p>Set zeta for YP exp(-zeta r12)/r12 or STG exp(-zeta r12) type integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_geom_">
<span class="sig-name descname"><span class="pre">set_geom_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms_or_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_geom_" title="Link to this definition"></a></dt>
<dd><p>Update geometry</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_nuc_mod">
<span class="sig-name descname"><span class="pre">set_nuc_mod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_nuc_mod" title="Link to this definition"></a></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_nuc_mod_">
<span class="sig-name descname"><span class="pre">set_nuc_mod_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_nuc_mod_" title="Link to this definition"></a></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_range_coulomb">
<span class="sig-name descname"><span class="pre">set_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Switch on range-separated Coulomb operator for <strong>all</strong> 2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>omega</strong> – <p>double</p>
<div class="line-block">
<div class="line">= 0 : Regular electron repulsion integral</div>
<div class="line">&gt; 0 : Long-range operator  erf(omega r12) / r12</div>
<div class="line">&lt; 0 : Short-range operator  erfc(omega r12) /r12</div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_range_coulomb_">
<span class="sig-name descname"><span class="pre">set_range_coulomb_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_range_coulomb_" title="Link to this definition"></a></dt>
<dd><p>Switch on range-separated Coulomb operator for <strong>all</strong> 2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>omega</strong> – <p>double</p>
<div class="line-block">
<div class="line">= 0 : Regular electron repulsion integral</div>
<div class="line">&gt; 0 : Long-range operator  erf(omega r12) / r12</div>
<div class="line">&lt; 0 : Short-range operator  erfc(omega r12) /r12</div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_rinv_orig">
<span class="sig-name descname"><span class="pre">set_rinv_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_rinv_orig" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_rinv_orig_">
<span class="sig-name descname"><span class="pre">set_rinv_orig_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_rinv_orig_" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_rinv_origin">
<span class="sig-name descname"><span class="pre">set_rinv_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_rinv_origin" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_rinv_origin_">
<span class="sig-name descname"><span class="pre">set_rinv_origin_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_rinv_origin_" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_rinv_zeta">
<span class="sig-name descname"><span class="pre">set_rinv_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_rinv_zeta" title="Link to this definition"></a></dt>
<dd><p>Assume the charge distribution on the “rinv_origin”.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.set_rinv_zeta_">
<span class="sig-name descname"><span class="pre">set_rinv_zeta_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.set_rinv_zeta_" title="Link to this definition"></a></dt>
<dd><p>Assume the charge distribution on the “rinv_origin”.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.space_group_symmetry">
<span class="sig-name descname"><span class="pre">space_group_symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.space_group_symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.sph2spinor_coeff">
<span class="sig-name descname"><span class="pre">sph2spinor_coeff</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.sph2spinor_coeff" title="Link to this definition"></a></dt>
<dd><p>Transformation matrix that transforms real-spherical GTOs to spinor
GTOs for all basis functions</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca</span><span class="p">,</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">sph2spinor_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_spinor&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ca</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">+=</span> <span class="n">cb</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">6.66133814775e-16</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.sph_labels">
<span class="sig-name descname"><span class="pre">sph_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.sph_labels" title="Link to this definition"></a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.spheric_labels">
<span class="sig-name descname"><span class="pre">spheric_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.spheric_labels" title="Link to this definition"></a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.spinor_labels">
<span class="sig-name descname"><span class="pre">spinor_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.spinor_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of spinor GTO functions</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.stdout">
<span class="sig-name descname"><span class="pre">stdout</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.stdout" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.symmetrize_mesh">
<span class="sig-name descname"><span class="pre">symmetrize_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.symmetrize_mesh" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.symmetry">
<span class="sig-name descname"><span class="pre">symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.symmetry_subgroup">
<span class="sig-name descname"><span class="pre">symmetry_subgroup</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.symmetry_subgroup" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.symmorphic">
<span class="sig-name descname"><span class="pre">symmorphic</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.symmorphic" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.time_reversal_map">
<span class="sig-name descname"><span class="pre">time_reversal_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.time_reversal_map" title="Link to this definition"></a></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have positive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math notranslate nohighlight">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math notranslate nohighlight">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.tmap">
<span class="sig-name descname"><span class="pre">tmap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.tmap" title="Link to this definition"></a></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have positive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math notranslate nohighlight">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math notranslate nohighlight">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.to_mol">
<span class="sig-name descname"><span class="pre">to_mol</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.to_mol" title="Link to this definition"></a></dt>
<dd><p>Return a Mole object using the same atoms and basis functions as
the Cell object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.to_uncontracted_cartesian_basis">
<span class="sig-name descname"><span class="pre">to_uncontracted_cartesian_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.to_uncontracted_cartesian_basis" title="Link to this definition"></a></dt>
<dd><p>Decontract the basis of a Mole or a Cell.  Returns a Mole (Cell) object
with uncontracted Cartesian basis and a list of coefficients that
transform the uncontracted basis to the original basis. Each element in
the coefficients list corresponds to one shell of the original Mole (Cell).</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Ne&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmol</span><span class="p">,</span> <span class="n">ctr_coeff</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">to_uncontracted_cartesian_basis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">ctr_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.tofile">
<span class="sig-name descname"><span class="pre">tofile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.tofile" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.tostring">
<span class="sig-name descname"><span class="pre">tostring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'poscar'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.tostring" title="Link to this definition"></a></dt>
<dd><p>Convert cell geometry to a string of the required format.</p>
<dl>
<dt>Supported output formats:</dt><dd><div class="line-block">
<div class="line">poscar: VASP POSCAR</div>
<div class="line">xyz: Extended XYZ with Lattice information</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.tot_electrons">
<span class="sig-name descname"><span class="pre">tot_electrons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nkpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.tot_electrons" title="Link to this definition"></a></dt>
<dd><p>Total number of electrons</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.unit">
<span class="sig-name descname"><span class="pre">unit</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'angstrom'</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.unit" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.unpack">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moldic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.unpack" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.unpack_">
<span class="sig-name descname"><span class="pre">unpack_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moldic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.unpack_" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.update" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.update_from_chk">
<span class="sig-name descname"><span class="pre">update_from_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.update_from_chk" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.use_loose_rcut">
<span class="sig-name descname"><span class="pre">use_loose_rcut</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.use_loose_rcut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.use_particle_mesh_ewald">
<span class="sig-name descname"><span class="pre">use_particle_mesh_ewald</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.use_particle_mesh_ewald" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.verbose" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.view">
<span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.view" title="Link to this definition"></a></dt>
<dd><p>New view of object with the same attributes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.vol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vol</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.vol" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.with_common_orig">
<span class="sig-name descname"><span class="pre">with_common_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.with_common_orig" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.with_common_origin">
<span class="sig-name descname"><span class="pre">with_common_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.with_common_origin" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.with_integral_screen">
<span class="sig-name descname"><span class="pre">with_integral_screen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.with_integral_screen" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the required integral
screen threshold</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.with_long_range_coulomb">
<span class="sig-name descname"><span class="pre">with_long_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.with_long_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context for long-range part of
range-separated Coulomb operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.with_range_coulomb">
<span class="sig-name descname"><span class="pre">with_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.with_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which sets the required parameter
omega for range-separated Coulomb operator.
If omega = None, return the context for regular Coulomb integrals.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_range_coulomb()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_range_coulomb</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int2e&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.with_rinv_as_nucleus">
<span class="sig-name descname"><span class="pre">with_rinv_as_nucleus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.with_rinv_as_nucleus" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context in which the rinv operator (1/r) is
treated like the Coulomb potential of a Gaussian charge distribution
rho(r) = Norm * exp(-zeta * r^2) at the place of the input atm_id.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_at_nucleus</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.with_rinv_at_nucleus">
<span class="sig-name descname"><span class="pre">with_rinv_at_nucleus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.with_rinv_at_nucleus" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context in which the rinv operator (1/r) is
treated like the Coulomb potential of a Gaussian charge distribution
rho(r) = Norm * exp(-zeta * r^2) at the place of the input atm_id.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_at_nucleus</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.with_rinv_orig">
<span class="sig-name descname"><span class="pre">with_rinv_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.with_rinv_orig" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.with_rinv_origin">
<span class="sig-name descname"><span class="pre">with_rinv_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.with_rinv_origin" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.with_rinv_zeta">
<span class="sig-name descname"><span class="pre">with_rinv_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.with_rinv_zeta" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired Gaussian charge
distribution placed at “rinv_origin”: rho(r) = Norm * exp(-zeta * r^2).
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_zeta()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_zeta</span><span class="p">(</span><span class="n">zeta</span><span class="o">=</span><span class="mf">1.5</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeMole.with_short_range_coulomb">
<span class="sig-name descname"><span class="pre">with_short_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeMole.with_short_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context for short-range part of
range-separated Coulomb operator.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.latt.</span></span><span class="sig-name descname"><span class="pre">Hubbard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsite</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelectron</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hubbard_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hubbard_u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_nn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#vayesta.lattmod.latt.LatticeMole" title="vayesta.lattmod.latt.LatticeMole"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatticeMole</span></code></a></p>
<p>Abstract Hubbard model class.</p>
<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.aoslice_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_by_atom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard.aoslice_by_atom"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.aoslice_by_atom" title="Link to this definition"></a></dt>
<dd><p>One basis function per site (“atom”).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.ao2mo">
<span class="sig-name descname"><span class="pre">ao2mo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard.ao2mo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.ao2mo" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.Gv">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Gv</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.Gv" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.ao_labels">
<span class="sig-name descname"><span class="pre">ao_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.ao_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of AO basis functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>fmt<span class="classifier">str or bool</span></dt><dd><p>if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-AO-notation)]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.ao_loc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ao_loc</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.ao_loc" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start basis function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.ao_loc_2c">
<span class="sig-name descname"><span class="pre">ao_loc_2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.ao_loc_2c" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spinor basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start id of spinor function</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_2c</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 2, 4, 6, 12, 18, 20, 22, 24, 30, 36]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.ao_loc_nr">
<span class="sig-name descname"><span class="pre">ao_loc_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.ao_loc_nr" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start basis function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.ao_rotation_matrix">
<span class="sig-name descname"><span class="pre">ao_rotation_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orientation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.ao_rotation_matrix" title="Link to this definition"></a></dt>
<dd><p>Matrix u to rotate AO basis to a new orientation.</p>
<p>atom_new_coords = mol.atom_coords().dot(orientation.T)
new_AO = u * mol.AO
new_orbitals_coef = u.dot(orbitals_coef)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.aoslice_2c_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_2c_by_atom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.aoslice_2c_by_atom" title="Link to this definition"></a></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.aoslice_nr_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_nr_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.aoslice_nr_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.apply" title="Link to this definition"></a></dt>
<dd><p>Apply the fn to rest arguments:  return <code class="docutils literal notranslate"><span class="pre">fn(*args,</span> <span class="pre">**kwargs)</span></code>.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.atom_charge">
<span class="sig-name descname"><span class="pre">atom_charge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.atom_charge" title="Link to this definition"></a></dt>
<dd><p>Nuclear effective charge of the given atom id
Note “atom_charge /= charge(atom_symbol)” when ECP is enabled.
Number of electrons screened by ECP can be obtained by charge(atom_symbol)-atom_charge</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">17</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.atom_charges">
<span class="sig-name descname"><span class="pre">atom_charges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.atom_charges" title="Link to this definition"></a></dt>
<dd><p>np.asarray([mol.atom_charge(i) for i in range(mol.natm)])</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.atom_coord">
<span class="sig-name descname"><span class="pre">atom_coord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Bohr'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.atom_coord" title="Link to this definition"></a></dt>
<dd><p>Coordinates (ndarray) of the given atom id</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.atom_coords">
<span class="sig-name descname"><span class="pre">atom_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Bohr'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.atom_coords" title="Link to this definition"></a></dt>
<dd><p>np.asarray([mol.atom_coord(i) for i in range(mol.natm)])</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.atom_mass_list">
<span class="sig-name descname"><span class="pre">atom_mass_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isotope_avg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.atom_mass_list" title="Link to this definition"></a></dt>
<dd><p>A list of mass for all atoms in the molecule</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>isotope_avg<span class="classifier">boolean</span></dt><dd><p>Whether to use the isotope average mass as the atomic mass</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.atom_nelec_core">
<span class="sig-name descname"><span class="pre">atom_nelec_core</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.atom_nelec_core" title="Link to this definition"></a></dt>
<dd><p>Number of core electrons for pseudo potential.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.atom_nshells">
<span class="sig-name descname"><span class="pre">atom_nshells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.atom_nshells" title="Link to this definition"></a></dt>
<dd><p>Number of basis/shells of the given atom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_nshells</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.atom_pure_symbol">
<span class="sig-name descname"><span class="pre">atom_pure_symbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">site</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.atom_pure_symbol" title="Link to this definition"></a></dt>
<dd><p>For the given atom id, return the standard symbol (striping special characters)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_pure_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.atom_shell_ids">
<span class="sig-name descname"><span class="pre">atom_shell_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.atom_shell_ids" title="Link to this definition"></a></dt>
<dd><p>A list of the shell-ids of the given atom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_shell_ids</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[3, 4, 5, 6, 7]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.atom_symbol">
<span class="sig-name descname"><span class="pre">atom_symbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">site</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.atom_symbol" title="Link to this definition"></a></dt>
<dd><p>For the given atom id, return the input symbol (without striping special characters)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H^2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_angular">
<span class="sig-name descname"><span class="pre">bas_angular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_angular" title="Link to this definition"></a></dt>
<dd><p>The angular momentum associated with the given basis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_angular</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_atom">
<span class="sig-name descname"><span class="pre">bas_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_atom" title="Link to this definition"></a></dt>
<dd><p>The atom (0-based id) that the given basis sits on</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_coord">
<span class="sig-name descname"><span class="pre">bas_coord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_coord" title="Link to this definition"></a></dt>
<dd><p>Coordinates (ndarray) associated with the given basis id</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_ctr_coeff">
<span class="sig-name descname"><span class="pre">bas_ctr_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_ctr_coeff" title="Link to this definition"></a></dt>
<dd><p>Contract coefficients (ndarray) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_ctr_coeff</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[[ 10.03400444]</span>
<span class="go"> [  4.1188704 ]</span>
<span class="go"> [  1.53971186]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_exp">
<span class="sig-name descname"><span class="pre">bas_exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_exp" title="Link to this definition"></a></dt>
<dd><p>exponents (ndarray) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_exp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[ 13.01     1.962    0.4446]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_exps">
<span class="sig-name descname"><span class="pre">bas_exps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_exps" title="Link to this definition"></a></dt>
<dd><p>exponents of all basis
return [mol.bas_exp(i) for i in range(self.nbas)]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_kappa">
<span class="sig-name descname"><span class="pre">bas_kappa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_kappa" title="Link to this definition"></a></dt>
<dd><p>Kappa (if l &lt; j, -l-1, else l) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_kappa</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_len_cart">
<span class="sig-name descname"><span class="pre">bas_len_cart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_len_cart" title="Link to this definition"></a></dt>
<dd><p>The number of Cartesian function associated with given basis</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_len_spinor">
<span class="sig-name descname"><span class="pre">bas_len_spinor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_len_spinor" title="Link to this definition"></a></dt>
<dd><p>The number of spinor associated with given basis
If kappa is 0, return 4l+2</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_nctr">
<span class="sig-name descname"><span class="pre">bas_nctr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_nctr" title="Link to this definition"></a></dt>
<dd><p>The number of contracted GTOs for the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_nctr</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_nprim">
<span class="sig-name descname"><span class="pre">bas_nprim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_nprim" title="Link to this definition"></a></dt>
<dd><p>The number of primitive GTOs for the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_nprim</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.bas_rcut">
<span class="sig-name descname"><span class="pre">bas_rcut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.bas_rcut" title="Link to this definition"></a></dt>
<dd><p>Estimate the largest distance between the function and its image to
reach the precision in overlap</p>
<p>precision ~ int g(r-0) g(r-Rcut)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dump_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parse_arg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_dim_ft_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmorphic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_loose_rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_particle_mesh_ewald</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fractional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.build" title="Link to this definition"></a></dt>
<dd><p>Setup Mole molecule and Cell and initialize some control parameters.
Whenever you change the value of the attributes of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code>,
you need call this function to refresh the internal data of Cell.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>a<span class="classifier">(3,3) ndarray</span></dt><dd><p>The real-space cell lattice vectors. Each row represents
a lattice vector.</p>
</dd>
<dt>fractional<span class="classifier">bool</span></dt><dd><p>Whether the atom postions are specified in fractional coordinates.
The default value is False, which means the coordinates are
interpreted as Cartesian coordinate.</p>
</dd>
<dt>mesh<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>The number of <em>positive</em> G-vectors along each direction.</p>
</dd>
<dt>ke_cutoff<span class="classifier">float</span></dt><dd><p>If set, defines a spherical cutoff of planewaves, with .5 * G**2 &lt; ke_cutoff
The default value is estimated based on <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard.precision" title="vayesta.lattmod.latt.Hubbard.precision"><code class="xref py py-attr docutils literal notranslate"><span class="pre">precision</span></code></a></p>
</dd>
<dt>precision<span class="classifier">float</span></dt><dd><p>To control Ewald sums and lattice sums accuracy</p>
</dd>
<dt>nimgs<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>Number of repeated images in lattice summation to produce
periodicity. This value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>rcut<span class="classifier">float</span></dt><dd><p>Cutoff radius (unit Bohr) in lattice summation to produce
periodicity. The value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>h<span class="classifier">(3,3) ndarray</span></dt><dd><p>a.T. Deprecated</p>
</dd>
<dt>dimension<span class="classifier">int</span></dt><dd><p>Default is 3</p>
</dd>
<dt>low_dim_ft_type<span class="classifier">str</span></dt><dd><p>For semi-empirical periodic systems, whether to calculate
integrals at the non-PBC dimension using the sampled mesh grids in
infinity vacuum (inf_vacuum) or truncated Coulomb potential
(analytic_2d_1). Unless explicitly specified, analytic_2d_1 is
used for 2D system and inf_vacuum is assumed for 1D and 0D.</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry. Default is False.</p>
</dd>
<dt>symmorphic<span class="classifier">bool</span></dt><dd><p>Whether the lattice is symmorphic. If set to True, even if the
lattice is non-symmorphic, only symmorphic space group symmetry
will be considered. Default is False, meaning the space group is
determined by the lattice symmetry to be symmorphic or non-symmorphic.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.build_lattice_symmetry">
<span class="sig-name descname"><span class="pre">build_lattice_symmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">check_mesh_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.build_lattice_symmetry" title="Link to this definition"></a></dt>
<dd><p>Build cell.lattice_symmetry object.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>check_mesh_symmetry<span class="classifier">bool</span></dt><dd><p>For nonsymmorphic symmetry groups, <cite>cell.mesh</cite> may have
lower symmetry than the lattice. In this case, if
<cite>check_mesh_symmetry</cite> is <cite>True</cite>, the lower symmetry group will
be used. Otherwise, if <cite>check_mesh_symmetry</cite> is <cite>False</cite>,
the mesh grid will be modified to satisfy the higher symmetry.
Default value is <cite>True</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function modifies the attributes of <cite>cell</cite>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.cart">
<span class="sig-name descname"><span class="pre">cart</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.cart" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.cart2sph_coeff">
<span class="sig-name descname"><span class="pre">cart2sph_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sp'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.cart2sph_coeff" title="Link to this definition"></a></dt>
<dd><p>Transformation matrix that transforms Cartesian GTOs to spherical
GTOs for all basis functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>normalized<span class="classifier">string or boolean</span></dt><dd><p>How the Cartesian GTOs are normalized.  Except s and p functions,
Cartesian GTOs do not have the universal normalization coefficients
for the different components of the same shell.  The value of this
argument can be one of ‘sp’, ‘all’, None.  ‘sp’ means the Cartesian s
and p basis are normalized.  ‘all’ means all Cartesian functions are
normalized.  None means none of the Cartesian functions are normalized.
The default value ‘sp’ is the convention used by libcint library.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">cart2sph_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_cart&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">4.58676826646e-15</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.cart_labels">
<span class="sig-name descname"><span class="pre">cart_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.cart_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of Cartesian GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-xyz-notation)]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.charge">
<span class="sig-name descname"><span class="pre">charge</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.charge" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.check_sanity">
<span class="sig-name descname"><span class="pre">check_sanity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.check_sanity" title="Link to this definition"></a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.condense_to_shell">
<span class="sig-name descname"><span class="pre">condense_to_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compressor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'max'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.condense_to_shell" title="Link to this definition"></a></dt>
<dd><p>The given matrix is first partitioned to blocks, based on AO shell as
delimiter. Then call compressor function to abstract each block.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>compressor</strong> – string or function
if compressor is a string, its value can be  sum, max, min, abssum,
absmax, absmin, norm</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.copy" title="Link to this definition"></a></dt>
<dd><p>Deepcopy of the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
<p>Some attributes are shared between the original and copied objects.
Deepcopy is utilized here to ensure that operations on the copied object do
not affect the original object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.cutoff_to_mesh">
<span class="sig-name descname"><span class="pre">cutoff_to_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.cutoff_to_mesh" title="Link to this definition"></a></dt>
<dd><p>Convert KE cutoff to FFT-mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ke_cutoff</strong> – float
KE energy cutoff in a.u.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(3,) array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.decontract_basis">
<span class="sig-name descname"><span class="pre">decontract_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.decontract_basis" title="Link to this definition"></a></dt>
<dd><p>Decontract the basis of a Mole or a Cell.  Returns a Mole (Cell) object
with the uncontracted basis environment and a list of coefficients that
transform the uncontracted basis to the original basis. Each element in
the coefficients list corresponds to one shell of the original Mole (Cell).</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>atoms: list or str</dt><dd><p>Atoms on which the basis to be decontracted. By default, all basis
are decontracted</p>
</dd>
<dt>to_cart: bool</dt><dd><p>Decontract basis and transfer to Cartesian basis</p>
</dd>
<dt>aggregate: bool</dt><dd><p>Whether to aggregate the transformation coefficients into a giant
transformation matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Ne&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmol</span><span class="p">,</span> <span class="n">ctr_coeff</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">decontract_basis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">ctr_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.dimension">
<span class="sig-name descname"><span class="pre">dimension</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.dimension" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.drop_exponent">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">drop_exponent</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.drop_exponent" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.dump_input">
<span class="sig-name descname"><span class="pre">dump_input</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.dump_input" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.dumps">
<span class="sig-name descname"><span class="pre">dumps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.dumps" title="Link to this definition"></a></dt>
<dd><p>Serialize Cell object to a JSON formatted str.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.elements">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">elements</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.elements" title="Link to this definition"></a></dt>
<dd><p>A list of elements in the molecule</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.energy_nuc">
<span class="sig-name descname"><span class="pre">energy_nuc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.energy_nuc" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.enuc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enuc</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.enuc" title="Link to this definition"></a></dt>
<dd><p>nuclear repulsion energy</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.etbs">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">etbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">etbs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.etbs" title="Link to this definition"></a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard.expand_etb" title="vayesta.lattmod.latt.Hubbard.expand_etb"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand_etb()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[</strong> (<em>etbs =</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.eval_ao">
<span class="sig-name descname"><span class="pre">eval_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.eval_ao" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.eval_gto">
<span class="sig-name descname"><span class="pre">eval_gto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.eval_gto" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.ew_cut">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ew_cut</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.ew_cut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.ew_eta">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ew_eta</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.ew_eta" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.ewald">
<span class="sig-name descname"><span class="pre">ewald</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.ewald" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.exp_to_discard">
<span class="sig-name descname"><span class="pre">exp_to_discard</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.exp_to_discard" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.expand_etb">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">expand_etb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.expand_etb" title="Link to this definition"></a></dt>
<dd><p>Generate the exponents of even tempered basis for <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code>.
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span>\<span class="n">alpha</span> <span class="o">*</span> \<span class="n">beta</span><span class="o">^</span><span class="p">{</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">}}</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">..</span> <span class="n">n</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l</strong> – int
Angular momentum</p></li>
<li><p><strong>n</strong> – int
Number of GTOs</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[1, [6.0, 1]], [1, [3.0, 1]], [1, [1.5, 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.expand_etbs">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">expand_etbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">etbs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.expand_etbs" title="Link to this definition"></a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard.expand_etb" title="vayesta.lattmod.latt.Hubbard.expand_etb"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand_etb()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[</strong> (<em>etbs =</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.format_atom">
<span class="sig-name descname"><span class="pre">format_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'angstrom'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.format_atom" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.atom</span></code> to the internal data format.
Including, changing the nuclear charge to atom symbol, converting the
coordinates to AU, rotate and shift the molecule.
If the <code class="xref py py-attr docutils literal notranslate"><span class="pre">atom</span></code> is a string, it takes “;” and “n”
for the mark to separate atoms;  “,” and arbitrary length of blank space
to separate the individual terms for an atom.  Blank line will be ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atoms</strong> – list or str
the same to <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.atom</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>origin<span class="classifier">ndarray</span></dt><dd><p>new axis origin.</p>
</dd>
<dt>axes<span class="classifier">ndarray</span></dt><dd><p>(new_x, new_y, new_z), new coordinates</p>
</dd>
<dt>unit<span class="classifier">str or number</span></dt><dd><p>If unit is one of strings (B, b, Bohr, bohr, AU, au), the coordinates
of the input atoms are the atomic unit;  If unit is one of strings
(A, a, Angstrom, angstrom, Ang, ang), the coordinates are in the
unit of angstrom;  If a number is given, the number are considered
as the Bohr value (in angstrom), which should be around 0.53.
Set unit=1 if wishing to preserve the unit of the coordinates.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl>
<dt>“atoms” in the internal format. The internal format is</dt><dd><div class="line-block">
<div class="line">atom = [[atom1, (x, y, z)],</div>
<div class="line-block">
<div class="line">[atom2, (x, y, z)],</div>
<div class="line">…</div>
<div class="line">[atomN, (x, y, z)]]</div>
</div>
</div>
</dd>
</dl>
</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">(</span><span class="s1">&#39;9,0,0,0; h@1 0 0 1&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H@1&#39;, [-1.0, -1.0, 0.0]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">([</span><span class="s1">&#39;9,0,0,0&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))],</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H&#39;, [-1, -1, 0]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.format_basis">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_tab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.format_basis" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code> to the internal data format.</p>
<dl>
<dt><a href="#id3"><span class="problematic" id="id4">``</span></a>{ atom: [(l, ((-exp, c_1, c_2, ..),</dt><dd><blockquote>
<div><p>(-exp, c_1, c_2, ..))),</p>
</div></blockquote>
<dl class="simple">
<dt>(l, ((-exp, c_1, c_2, ..),</dt><dd><p>(-exp, c_1, c_2, ..)))], … }``</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>basis_tab</strong> – dict
Similar to <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code>, it <strong>cannot</strong> be a str</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="s1">&#39;H^2&#39;</span><span class="p">:</span> <span class="s1">&#39;3-21g&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    [3.4252509099999999, 0.15432897000000001],</span>
<span class="go">    [0.62391373000000006, 0.53532813999999995],</span>
<span class="go">    [0.16885539999999999, 0.44463454000000002]]],</span>
<span class="go"> &#39;H^2&#39;: [[0,</span>
<span class="go">    [5.4471780000000001, 0.15628500000000001],</span>
<span class="go">    [0.82454700000000003, 0.90469100000000002]],</span>
<span class="go">    [0, [0.18319199999999999, 1.0]]]}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;gth-szv&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    (8.3744350009, -0.0283380461),</span>
<span class="go">    (1.8058681460, -0.1333810052),</span>
<span class="go">    (0.4852528328, -0.3995676063),</span>
<span class="go">    (0.1658236932, -0.5531027541)]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.format_ecp">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_ecp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ecp_tab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.format_ecp" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">ecp</span></code> (dict) to the internal data format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span><span class="n">nelec</span><span class="p">,</span>  <span class="c1"># core electrons</span>
</pre></div>
</div>
<blockquote>
<div><blockquote>
<div><dl>
<dt>((l,  # l=-1 for UL, l&gt;=0 for Ul to indicate <a href="#id24"><span class="problematic" id="id25">|l&gt;&lt;l|</span></a></dt><dd><dl>
<dt>(((exp_1, c_1),  # for r^0</dt><dd><blockquote>
<div><p>(exp_2, c_2),
…),</p>
</div></blockquote>
<dl class="simple">
<dt>((exp_1, c_1),  # for r^1</dt><dd><p>(exp_2, c_2),
…),</p>
</dd>
<dt>((exp_1, c_1),  # for r^2</dt><dd><p>…))))),</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>…}</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.format_pseudo">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_pseudo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pseudo_tab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.format_pseudo" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code> (dict) to the internal data format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span> <span class="p">(</span><span class="n">nelec_s</span><span class="p">,</span> <span class="n">nele_p</span><span class="p">,</span> <span class="n">nelec_d</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>
         <span class="n">rloc</span><span class="p">,</span> <span class="n">nexp</span><span class="p">,</span> <span class="p">(</span><span class="n">cexp_1</span><span class="p">,</span> <span class="n">cexp_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">cexp_nexp</span><span class="p">),</span>
         <span class="n">nproj_types</span><span class="p">,</span>
         <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">nproj1</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
                        <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
                        <span class="o">...</span>
                        <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="n">nproj1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="n">nproj1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span>        <span class="p">)</span> <span class="p">)),</span>
         <span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">nproj2</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
         <span class="o">...</span> <span class="p">)</span> <span class="p">)</span>
         <span class="p">)</span>
 <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pseudo_tab</strong> – dict
Similar to <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code> (a dict), it <strong>cannot</strong> be a str</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pbc</span><span class="o">.</span><span class="n">format_pseudo</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;gth-blyp&#39;</span><span class="p">,</span> <span class="s1">&#39;He&#39;</span><span class="p">:</span> <span class="s1">&#39;gth-pade&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[1],</span>
<span class="go">    0.2, 2, [-4.19596147, 0.73049821], 0],</span>
<span class="go"> &#39;He&#39;: [[2],</span>
<span class="go">    0.2, 2, [-9.1120234, 1.69836797], 0]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.fractional">
<span class="sig-name descname"><span class="pre">fractional</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.fractional" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.from_ase">
<span class="sig-name descname"><span class="pre">from_ase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ase_atom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.from_ase" title="Link to this definition"></a></dt>
<dd><p>Update cell based on given ase atom object</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ase.lattice</span><span class="w"> </span><span class="kn">import</span> <span class="n">bulk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">from_ase</span><span class="p">(</span><span class="n">bulk</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">LATTICE_CONST</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.fromfile">
<span class="sig-name descname"><span class="pre">fromfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.fromfile" title="Link to this definition"></a></dt>
<dd><p>Update the Cell object based on the input geometry file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.fromstring">
<span class="sig-name descname"><span class="pre">fromstring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'poscar'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.fromstring" title="Link to this definition"></a></dt>
<dd><p>Update the Cell object based on the input geometry string</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.gen_uniform_grids">
<span class="sig-name descname"><span class="pre">gen_uniform_grids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.gen_uniform_grids" title="Link to this definition"></a></dt>
<dd><p>Generate a uniform real-space grid consistent w/ samp thm; see MH (3.19).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngx*ngy*ngz, 3) ndarray</dt><dd><p>The real-space grid point coordinates.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>coords</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_Gv">
<span class="sig-name descname"><span class="pre">get_Gv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_Gv" title="Link to this definition"></a></dt>
<dd><p>Calculate three-dimensional G-vectors for the cell; see MH (3.8).</p>
<p>Indices along each direction go as [0…N-1, -N…-1] to follow FFT convention.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngrids, 3) ndarray of floats</dt><dd><p>The array of G-vectors.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Gv</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_Gv_weights">
<span class="sig-name descname"><span class="pre">get_Gv_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_Gv_weights" title="Link to this definition"></a></dt>
<dd><p>Calculate G-vectors and weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>(ngris, 3) ndarray of floats</dt><dd><p>The array of G-vectors.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Gv</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_SI">
<span class="sig-name descname"><span class="pre">get_SI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Gv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmlst</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_SI" title="Link to this definition"></a></dt>
<dd><p>Calculate the structure factor (0D, 1D, 2D, 3D) for all atoms; see MH (3.34).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p></li>
<li><p><strong>Gv</strong> – (N,3) array
G vectors</p></li>
<li><p><strong>atmlst</strong> – list of ints, optional
Indices of atoms for which the structure factors are computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(natm, ngrids) ndarray, dtype=np.complex128</dt><dd><p>The structure factor for each atom at each G-vector.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SI</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_abs_kpts">
<span class="sig-name descname"><span class="pre">get_abs_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scaled_kpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_abs_kpts" title="Link to this definition"></a></dt>
<dd><p>Get absolute k-points (in 1/Bohr), given “scaled” k-points in
fractions of lattice vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>scaled_kpts</strong> – (nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>abs_kpts</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_ao_indices">
<span class="sig-name descname"><span class="pre">get_ao_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_ao_indices" title="Link to this definition"></a></dt>
<dd><p>Generate (dis-continued) AO indices for basis specified in bas_list</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_bounding_sphere">
<span class="sig-name descname"><span class="pre">get_bounding_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rcut</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_bounding_sphere" title="Link to this definition"></a></dt>
<dd><p>Finds all the lattice points within a sphere of radius rcut.</p>
<p>Defines a parallelepiped given by -N_x &lt;= n_x &lt;= N_x, with x in [1,3]
See Martin p. 85</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rcut</strong> – number
real space cut-off for interaction</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray of 3 ints defining N_x</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>cut</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_enuc">
<span class="sig-name descname"><span class="pre">get_enuc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_enuc" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_ewald_params">
<span class="sig-name descname"><span class="pre">get_ewald_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_ewald_params" title="Link to this definition"></a></dt>
<dd><p>Choose a reasonable value of Ewald ‘eta’ and ‘cut’ parameters.
eta^2 is the exponent coefficient of the model Gaussian charge for nucleus
at R:  frac{eta^3}{pi^1.5} e^{-eta^2 (r-R)^2}</p>
<p>Choice is based on largest G vector and desired relative precision.</p>
<p>The relative error in the G-space sum is given by</p>
<blockquote>
<div><p>precision ~ 4pi Gmax^2 e^{(-Gmax^2)/(4 eta^2)}</p>
</div></blockquote>
<p>which determines eta. Then, real-space cutoff is determined by (exp.
factors only)</p>
<blockquote>
<div><p>precision ~ erfc(eta*rcut) / rcut ~ e^{(-eta**2 rcut*2)}</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald ‘eta’ and ‘cut’ parameters.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ew_eta, ew_cut</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_kpts">
<span class="sig-name descname"><span class="pre">get_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_gamma_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_reversal_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_kpts" title="Link to this definition"></a></dt>
<dd><p>Given number of kpoints along x,y,z , generate kpoints</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nks</strong> – (3,) ndarray</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>wrap_around<span class="classifier">bool</span></dt><dd><p>To ensure all kpts are in first Brillouin zone.</p>
</dd>
<dt>with_gamma_point<span class="classifier">bool</span></dt><dd><p>Whether to shift Monkhorst-pack grid to include gamma-point.</p>
</dd>
<dt>scaled_center<span class="classifier">(3,) array</span></dt><dd><p>Shift all points in the Monkhorst-pack grid to be centered on
scaled_center, given as the zeroth index of the returned kpts.
Scaled meaning that the k-points are scaled to a grid from
[-1,1] x [-1,1] x [-1,1]</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry</p>
</dd>
<dt>time_reversal_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider time reversal symmetry</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>kpts in absolute value (unit 1/Bohr).  Gamma point is placed at the
first place in the k-points list;
instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> if k-point symmetry is considered</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_lattice_Ls">
<span class="sig-name descname"><span class="pre">get_lattice_Ls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_lattice_Ls" title="Link to this definition"></a></dt>
<dd><p>Get the (Cartesian, unitful) lattice translation vectors for nearby images.
The translation vectors can be used for the lattice summation.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>discard:</dt><dd><p>Drop less important Ls based on AO values on grid</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_nimgs">
<span class="sig-name descname"><span class="pre">get_nimgs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_nimgs" title="Link to this definition"></a></dt>
<dd><p>Choose number of basis function images in lattice sums
to include for given precision in overlap, using</p>
<p>precision ~ int r^l e^{-alpha r^2} (r-rcut)^l e^{-alpha (r-rcut)^2}
~ (rcut^2/(2alpha))^l e^{alpha/2 rcut^2}</p>
<p>where alpha is the smallest exponent in the basis. Note
that assumes an isolated exponent in the middle of the box, so
it adds one additional lattice vector to be safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_overlap_cond">
<span class="sig-name descname"><span class="pre">get_overlap_cond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_overlap_cond" title="Link to this definition"></a></dt>
<dd><p>Overlap magnitudes measured by -log(overlap) between two shells</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>2D mask array of shape (nbas,nbas)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_scaled_atom_coords">
<span class="sig-name descname"><span class="pre">get_scaled_atom_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_scaled_atom_coords" title="Link to this definition"></a></dt>
<dd><p>Get scaled atomic coordinates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_scaled_kpts">
<span class="sig-name descname"><span class="pre">get_scaled_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">abs_kpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts_in_ibz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_scaled_kpts" title="Link to this definition"></a></dt>
<dd><p>Get scaled k-points, given absolute k-points in 1/Bohr.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>abs_kpts</strong> – (nkpts, 3) ndarray of floats or <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> object</p></li>
<li><p><strong>kpts_in_ibz</strong> – bool
If True, return k-points in IBZ; otherwise, return k-points in BZ.
Default value is True. This has effects only if abs_kpts is a
<code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>scaled_kpts</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.get_uniform_grids">
<span class="sig-name descname"><span class="pre">get_uniform_grids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.get_uniform_grids" title="Link to this definition"></a></dt>
<dd><p>Generate a uniform real-space grid consistent w/ samp thm; see MH (3.19).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngx*ngy*ngz, 3) ndarray</dt><dd><p>The real-space grid point coordinates.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>coords</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.gs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gs</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.gs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.gto_norm">
<span class="sig-name descname"><span class="pre">gto_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expnt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.gto_norm" title="Link to this definition"></a></dt>
<dd><p>Normalized factor for GTO radial part   <span class="math notranslate nohighlight">\(g=r^l e^{-\alpha r^2}\)</span></p>
<div class="math notranslate nohighlight">
\[\frac{1}{\sqrt{\int g^2 r^2 dr}}
= \sqrt{\frac{2^{2l+3} (l+1)! (2a)^{l+1.5}}{(2l+2)!\sqrt{\pi}}}\]</div>
<p>Ref: H. B. Schlegel and M. J. Frisch, Int. J. Quant.  Chem., 54(1995), 83-87.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l</strong> (<em>int</em>) – angular momentum</p></li>
<li><p><strong>expnt</strong> – exponent <span class="math notranslate nohighlight">\(\alpha\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>normalization factor</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gto_norm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">2.5264751109842591</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.h">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">h</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.h" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.has_ecp">
<span class="sig-name descname"><span class="pre">has_ecp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.has_ecp" title="Link to this definition"></a></dt>
<dd><p>Whether pseudo potential is used in the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.has_ecp_soc">
<span class="sig-name descname"><span class="pre">has_ecp_soc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.has_ecp_soc" title="Link to this definition"></a></dt>
<dd><p>Whether spin-orbit coupling is enabled in ECP.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.incore_anyway">
<span class="sig-name descname"><span class="pre">incore_anyway</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.incore_anyway" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.intor">
<span class="sig-name descname"><span class="pre">intor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s1'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.intor" title="Link to this definition"></a></dt>
<dd><p>Integral generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1e or 2e AO integrals.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Symmetry of the integrals</p>
<div class="line-block">
<div class="line">0 : no symmetry assumed (default)</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>shls_slice<span class="classifier">4-element, 6-element or 8-element tuple</span></dt><dd><p>Label the start-stop shells for each index in the integral.
For example, the 8-element tuple for the 2-electron integral
tensor (ij|kl) = intor(‘int2e’) are specified as
(ish_start, ish_end, jsh_start, jsh_end, ksh_start, ksh_end, lsh_start, lsh_end)</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ipnuc_sph&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># &lt;nabla i | V_nuc | j&gt;</span>
<span class="go">[[[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.10289944  0.48176097]</span>
<span class="go">  [-0.48176097 -0.10289944]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.intor_asymmetric">
<span class="sig-name descname"><span class="pre">intor_asymmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.intor_asymmetric" title="Link to this definition"></a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be anti-hermitian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp has 3 components.</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_asymmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j  0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j  0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.intor_by_shell">
<span class="sig-name descname"><span class="pre">intor_by_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.intor_by_shell" title="Link to this definition"></a></dt>
<dd><p>For given 2, 3 or 4 shells, interface for libcint to get 1e, 2e,
2-center-2e or 3-center-2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>intor_name</strong> – str
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the supported intor_name</p></li>
<li><p><strong>shls</strong> – list of int
The AO shell-ids of the integrals</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp has 3 components.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 2-dim to 5-dim, depending on the integral type (1e,
2e, 3c-2e, 2c2e) and the value of comp</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The gradients of the spherical 2e integrals</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">getints_by_shell</span><span class="p">(</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[[[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.08760462]]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.intor_symmetric">
<span class="sig-name descname"><span class="pre">intor_symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.intor_symmetric" title="Link to this definition"></a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be hermitian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_symmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.kernel">
<span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dump_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parse_arg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_dim_ft_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmorphic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_loose_rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_particle_mesh_ewald</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fractional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.kernel" title="Link to this definition"></a></dt>
<dd><p>Setup Mole molecule and Cell and initialize some control parameters.
Whenever you change the value of the attributes of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code>,
you need call this function to refresh the internal data of Cell.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>a<span class="classifier">(3,3) ndarray</span></dt><dd><p>The real-space cell lattice vectors. Each row represents
a lattice vector.</p>
</dd>
<dt>fractional<span class="classifier">bool</span></dt><dd><p>Whether the atom postions are specified in fractional coordinates.
The default value is False, which means the coordinates are
interpreted as Cartesian coordinate.</p>
</dd>
<dt>mesh<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>The number of <em>positive</em> G-vectors along each direction.</p>
</dd>
<dt>ke_cutoff<span class="classifier">float</span></dt><dd><p>If set, defines a spherical cutoff of planewaves, with .5 * G**2 &lt; ke_cutoff
The default value is estimated based on <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard.precision" title="vayesta.lattmod.latt.Hubbard.precision"><code class="xref py py-attr docutils literal notranslate"><span class="pre">precision</span></code></a></p>
</dd>
<dt>precision<span class="classifier">float</span></dt><dd><p>To control Ewald sums and lattice sums accuracy</p>
</dd>
<dt>nimgs<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>Number of repeated images in lattice summation to produce
periodicity. This value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>rcut<span class="classifier">float</span></dt><dd><p>Cutoff radius (unit Bohr) in lattice summation to produce
periodicity. The value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>h<span class="classifier">(3,3) ndarray</span></dt><dd><p>a.T. Deprecated</p>
</dd>
<dt>dimension<span class="classifier">int</span></dt><dd><p>Default is 3</p>
</dd>
<dt>low_dim_ft_type<span class="classifier">str</span></dt><dd><p>For semi-empirical periodic systems, whether to calculate
integrals at the non-PBC dimension using the sampled mesh grids in
infinity vacuum (inf_vacuum) or truncated Coulomb potential
(analytic_2d_1). Unless explicitly specified, analytic_2d_1 is
used for 2D system and inf_vacuum is assumed for 1D and 0D.</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry. Default is False.</p>
</dd>
<dt>symmorphic<span class="classifier">bool</span></dt><dd><p>Whether the lattice is symmorphic. If set to True, even if the
lattice is non-symmorphic, only symmorphic space group symmetry
will be considered. Default is False, meaning the space group is
determined by the lattice symmetry to be symmorphic or non-symmorphic.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.lattice_symmetry">
<span class="sig-name descname"><span class="pre">lattice_symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.lattice_symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.lattice_vectors">
<span class="sig-name descname"><span class="pre">lattice_vectors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.lattice_vectors" title="Link to this definition"></a></dt>
<dd><p>Convert the primitive lattice vectors.</p>
<p>Return 3x3 array in which each row represents one direction of the
lattice vectors (unit in Bohr)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.loads">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molstr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.loads" title="Link to this definition"></a></dt>
<dd><p>Deserialize a str containing a JSON document to a Cell object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.loads_">
<span class="sig-name descname"><span class="pre">loads_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molstr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.loads_" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.low_dim_ft_type">
<span class="sig-name descname"><span class="pre">low_dim_ft_type</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.low_dim_ft_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.make_atm_env">
<span class="sig-name descname"><span class="pre">make_atm_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucmod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucprop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.make_atm_env" title="Link to this definition"></a></dt>
<dd><p>Convert the internal format <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._atom</span></code> to the format required
by <code class="docutils literal notranslate"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.make_bas_env">
<span class="sig-name descname"><span class="pre">make_bas_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_add</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.make_bas_env" title="Link to this definition"></a></dt>
<dd><p>Convert <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code> to the argument <code class="docutils literal notranslate"><span class="pre">bas</span></code> for <code class="docutils literal notranslate"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.make_ecp_env">
<span class="sig-name descname"><span class="pre">make_ecp_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_atm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_ecp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.make_ecp_env" title="Link to this definition"></a></dt>
<dd><p>Generate the input arguments _ecpbas for ECP integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.make_env">
<span class="sig-name descname"><span class="pre">make_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucmod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucprop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.make_env" title="Link to this definition"></a></dt>
<dd><p>Generate the input arguments for <code class="docutils literal notranslate"><span class="pre">libcint</span></code> library based on internal
format <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._atom</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._basis</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.make_kpts">
<span class="sig-name descname"><span class="pre">make_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_gamma_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_reversal_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.make_kpts" title="Link to this definition"></a></dt>
<dd><p>Given number of kpoints along x,y,z , generate kpoints</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nks</strong> – (3,) ndarray</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>wrap_around<span class="classifier">bool</span></dt><dd><p>To ensure all kpts are in first Brillouin zone.</p>
</dd>
<dt>with_gamma_point<span class="classifier">bool</span></dt><dd><p>Whether to shift Monkhorst-pack grid to include gamma-point.</p>
</dd>
<dt>scaled_center<span class="classifier">(3,) array</span></dt><dd><p>Shift all points in the Monkhorst-pack grid to be centered on
scaled_center, given as the zeroth index of the returned kpts.
Scaled meaning that the k-points are scaled to a grid from
[-1,1] x [-1,1] x [-1,1]</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry</p>
</dd>
<dt>time_reversal_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider time reversal symmetry</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>kpts in absolute value (unit 1/Bohr).  Gamma point is placed at the
first place in the k-points list;
instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> if k-point symmetry is considered</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.max_memory">
<span class="sig-name descname"><span class="pre">max_memory</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4000</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.max_memory" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.mesh">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mesh</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.mesh" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.ms">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ms</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.ms" title="Link to this definition"></a></dt>
<dd><p>Spin quantum number. multiplicity = ms*2+1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.multiplicity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">multiplicity</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.multiplicity" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.nao">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nao</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.nao" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.nao_2c">
<span class="sig-name descname"><span class="pre">nao_2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.nao_2c" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted spinor GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.nao_2c_range">
<span class="sig-name descname"><span class="pre">nao_2c_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bas_id1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.nao_2c_range" title="Link to this definition"></a></dt>
<dd><p>Lower and upper boundary of contracted spinor basis functions associated
with the given shell range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p></li>
<li><p><strong>bas_id0</strong> – int
start shell id, 0-based</p></li>
<li><p><strong>bas_id1</strong> – int
stop shell id, 0-based</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple of start basis function id and the stop function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_2c_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(4, 12)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.nao_cart">
<span class="sig-name descname"><span class="pre">nao_cart</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.nao_cart" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted cartesian GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.nao_nr">
<span class="sig-name descname"><span class="pre">nao_nr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.nao_nr" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.nao_nr_range">
<span class="sig-name descname"><span class="pre">nao_nr_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bas_id1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.nao_nr_range" title="Link to this definition"></a></dt>
<dd><p>Lower and upper boundary of contracted spherical basis functions associated
with the given shell range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p></li>
<li><p><strong>bas_id0</strong> – int
start shell id</p></li>
<li><p><strong>bas_id1</strong> – int
stop shell id</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple of start basis function id and the stop function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_nr_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(2, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.natm">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">natm</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.natm" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.nbas">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nbas</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.nbas" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.nelec">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.nelec" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.nelectron">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelectron</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.nelectron" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.nimgs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nimgs</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.nimgs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.npgto_nr">
<span class="sig-name descname"><span class="pre">npgto_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.npgto_nr" title="Link to this definition"></a></dt>
<dd><p>Total number of primitive spherical GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.offset_2c_by_atom">
<span class="sig-name descname"><span class="pre">offset_2c_by_atom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.offset_2c_by_atom" title="Link to this definition"></a></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.offset_ao_by_atom">
<span class="sig-name descname"><span class="pre">offset_ao_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.offset_ao_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.offset_nr_by_atom">
<span class="sig-name descname"><span class="pre">offset_nr_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.offset_nr_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.omega">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">omega</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.omega" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.output">
<span class="sig-name descname"><span class="pre">output</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.output" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.pack">
<span class="sig-name descname"><span class="pre">pack</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.pack" title="Link to this definition"></a></dt>
<dd><p>Pack the input args of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> to a dict, which can be serialized
with <code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.pbc_eval_ao">
<span class="sig-name descname"><span class="pre">pbc_eval_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.pbc_eval_ao" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.pbc_eval_gto">
<span class="sig-name descname"><span class="pre">pbc_eval_gto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.pbc_eval_gto" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.pbc_intor">
<span class="sig-name descname"><span class="pre">pbc_intor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.pbc_intor" title="Link to this definition"></a></dt>
<dd><p>One-electron integrals with PBC.</p>
<div class="math notranslate nohighlight">
\[\sum_T \int \mu(r) * [intor] * \nu (r-T) dr\]</div>
<p>See also Mole.intor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.post_kernel">
<span class="sig-name descname"><span class="pre">post_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.post_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run after the main body of the kernel function.  Internal
variables are exposed to post_kernel through the “envs” dictionary.
Return value of post_kernel function is not required.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.pre_kernel">
<span class="sig-name descname"><span class="pre">pre_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.pre_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run before the main body of kernel function is executed.
Internal variables are exposed to pre_kernel through the “envs”
dictionary.  Return value of pre_kernel function is not required.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.precision">
<span class="sig-name descname"><span class="pre">precision</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-08</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.precision" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.rcut">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rcut</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.rcut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.rcut_by_shells">
<span class="sig-name descname"><span class="pre">rcut_by_shells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_pgf_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.rcut_by_shells" title="Link to this definition"></a></dt>
<dd><p>Compute shell and primitive gaussian function radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.reciprocal_vectors">
<span class="sig-name descname"><span class="pre">reciprocal_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.283185307179586</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.reciprocal_vectors" title="Link to this definition"></a></dt>
<dd><div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\mathbf{b_1} &amp;= 2\pi \frac{\mathbf{a_2} \times \mathbf{a_3}}{\mathbf{a_1} \cdot (\mathbf{a_2} \times \mathbf{a_3})} \\
\mathbf{b_2} &amp;= 2\pi \frac{\mathbf{a_3} \times \mathbf{a_1}}{\mathbf{a_2} \cdot (\mathbf{a_3} \times \mathbf{a_1})} \\
\mathbf{b_3} &amp;= 2\pi \frac{\mathbf{a_1} \times \mathbf{a_2}}{\mathbf{a_3} \cdot (\mathbf{a_1} \times \mathbf{a_2})}
\end{align}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.reset" title="Link to this definition"></a></dt>
<dd><p>Clean up intermediates</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.run" title="Link to this definition"></a></dt>
<dd><p>Call the kernel function of current object.  <cite>args</cite> will be passed
to kernel function.  <cite>kwargs</cite> will be used to update the attributes of
current object.  The return value of method run is the object itself.
This allows a series of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.search_ao_label">
<span class="sig-name descname"><span class="pre">search_ao_label</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.search_ao_label" title="Link to this definition"></a></dt>
<dd><p>Find the index of the AO basis function based on the given ao_label</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ao_label</strong> – string or a list of strings
The regular expression pattern to match the orbital labels
returned by mol.ao_labels()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of index for the AOs that matches the given ao_label RE pattern</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl.*p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21 22 23 24 25 26 27 28 29 30]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl 2p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">([</span><span class="s1">&#39;Cl.*d&#39;</span><span class="p">,</span> <span class="s1">&#39;Cl 4p&#39;</span><span class="p">])</span>
<span class="go">[25 26 27 31 32 33 34 35 36 37 38 39 40]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.search_ao_nr">
<span class="sig-name descname"><span class="pre">search_ao_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmshell</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.search_ao_nr" title="Link to this definition"></a></dt>
<dd><p>Search the first basis function id (<strong>not</strong> the shell id) which matches
the given atom-id, angular momentum magnetic angular momentum, principal shell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atm_id</strong> – int
atom id, 0-based</p></li>
<li><p><strong>l</strong> – int
angular momentum</p></li>
<li><p><strong>m</strong> – int
magnetic angular momentum</p></li>
<li><p><strong>atmshell</strong> – int
principal quantum number</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>basis function id, 0-based.  If not found, return None</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_nr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Cl 3px</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.search_ao_r">
<span class="sig-name descname"><span class="pre">search_ao_r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmshell</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.search_ao_r" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.search_shell_id">
<span class="sig-name descname"><span class="pre">search_shell_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.search_shell_id" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set" title="Link to this definition"></a></dt>
<dd><p>Update the attributes of the current object.  The return value of
method set is the object itself.  This allows a series of
functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_common_orig">
<span class="sig-name descname"><span class="pre">set_common_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_common_orig" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_common_orig_">
<span class="sig-name descname"><span class="pre">set_common_orig_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_common_orig_" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_common_origin">
<span class="sig-name descname"><span class="pre">set_common_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_common_origin" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_common_origin_">
<span class="sig-name descname"><span class="pre">set_common_origin_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_common_origin_" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_f12_zeta">
<span class="sig-name descname"><span class="pre">set_f12_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_f12_zeta" title="Link to this definition"></a></dt>
<dd><p>Set zeta for YP exp(-zeta r12)/r12 or STG exp(-zeta r12) type integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_geom_">
<span class="sig-name descname"><span class="pre">set_geom_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms_or_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_geom_" title="Link to this definition"></a></dt>
<dd><p>Update geometry</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_nuc_mod">
<span class="sig-name descname"><span class="pre">set_nuc_mod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_nuc_mod" title="Link to this definition"></a></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_nuc_mod_">
<span class="sig-name descname"><span class="pre">set_nuc_mod_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_nuc_mod_" title="Link to this definition"></a></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_range_coulomb">
<span class="sig-name descname"><span class="pre">set_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Switch on range-separated Coulomb operator for <strong>all</strong> 2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>omega</strong> – <p>double</p>
<div class="line-block">
<div class="line">= 0 : Regular electron repulsion integral</div>
<div class="line">&gt; 0 : Long-range operator  erf(omega r12) / r12</div>
<div class="line">&lt; 0 : Short-range operator  erfc(omega r12) /r12</div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_range_coulomb_">
<span class="sig-name descname"><span class="pre">set_range_coulomb_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_range_coulomb_" title="Link to this definition"></a></dt>
<dd><p>Switch on range-separated Coulomb operator for <strong>all</strong> 2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>omega</strong> – <p>double</p>
<div class="line-block">
<div class="line">= 0 : Regular electron repulsion integral</div>
<div class="line">&gt; 0 : Long-range operator  erf(omega r12) / r12</div>
<div class="line">&lt; 0 : Short-range operator  erfc(omega r12) /r12</div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_rinv_orig">
<span class="sig-name descname"><span class="pre">set_rinv_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_rinv_orig" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_rinv_orig_">
<span class="sig-name descname"><span class="pre">set_rinv_orig_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_rinv_orig_" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_rinv_origin">
<span class="sig-name descname"><span class="pre">set_rinv_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_rinv_origin" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_rinv_origin_">
<span class="sig-name descname"><span class="pre">set_rinv_origin_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_rinv_origin_" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_rinv_zeta">
<span class="sig-name descname"><span class="pre">set_rinv_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_rinv_zeta" title="Link to this definition"></a></dt>
<dd><p>Assume the charge distribution on the “rinv_origin”.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.set_rinv_zeta_">
<span class="sig-name descname"><span class="pre">set_rinv_zeta_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.set_rinv_zeta_" title="Link to this definition"></a></dt>
<dd><p>Assume the charge distribution on the “rinv_origin”.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.space_group_symmetry">
<span class="sig-name descname"><span class="pre">space_group_symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.space_group_symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.sph2spinor_coeff">
<span class="sig-name descname"><span class="pre">sph2spinor_coeff</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.sph2spinor_coeff" title="Link to this definition"></a></dt>
<dd><p>Transformation matrix that transforms real-spherical GTOs to spinor
GTOs for all basis functions</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca</span><span class="p">,</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">sph2spinor_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_spinor&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ca</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">+=</span> <span class="n">cb</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">6.66133814775e-16</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.sph_labels">
<span class="sig-name descname"><span class="pre">sph_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.sph_labels" title="Link to this definition"></a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.spheric_labels">
<span class="sig-name descname"><span class="pre">spheric_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.spheric_labels" title="Link to this definition"></a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.spin">
<span class="sig-name descname"><span class="pre">spin</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.spin" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.spinor_labels">
<span class="sig-name descname"><span class="pre">spinor_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.spinor_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of spinor GTO functions</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.stdout">
<span class="sig-name descname"><span class="pre">stdout</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.stdout" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.symmetrize_mesh">
<span class="sig-name descname"><span class="pre">symmetrize_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.symmetrize_mesh" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.symmetry">
<span class="sig-name descname"><span class="pre">symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.symmetry_subgroup">
<span class="sig-name descname"><span class="pre">symmetry_subgroup</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.symmetry_subgroup" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.symmorphic">
<span class="sig-name descname"><span class="pre">symmorphic</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.symmorphic" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.time_reversal_map">
<span class="sig-name descname"><span class="pre">time_reversal_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.time_reversal_map" title="Link to this definition"></a></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have positive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math notranslate nohighlight">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math notranslate nohighlight">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.tmap">
<span class="sig-name descname"><span class="pre">tmap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.tmap" title="Link to this definition"></a></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have positive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math notranslate nohighlight">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math notranslate nohighlight">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.to_mol">
<span class="sig-name descname"><span class="pre">to_mol</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.to_mol" title="Link to this definition"></a></dt>
<dd><p>Return a Mole object using the same atoms and basis functions as
the Cell object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.to_uncontracted_cartesian_basis">
<span class="sig-name descname"><span class="pre">to_uncontracted_cartesian_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.to_uncontracted_cartesian_basis" title="Link to this definition"></a></dt>
<dd><p>Decontract the basis of a Mole or a Cell.  Returns a Mole (Cell) object
with uncontracted Cartesian basis and a list of coefficients that
transform the uncontracted basis to the original basis. Each element in
the coefficients list corresponds to one shell of the original Mole (Cell).</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Ne&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmol</span><span class="p">,</span> <span class="n">ctr_coeff</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">to_uncontracted_cartesian_basis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">ctr_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.tofile">
<span class="sig-name descname"><span class="pre">tofile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.tofile" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.tostring">
<span class="sig-name descname"><span class="pre">tostring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'poscar'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.tostring" title="Link to this definition"></a></dt>
<dd><p>Convert cell geometry to a string of the required format.</p>
<dl>
<dt>Supported output formats:</dt><dd><div class="line-block">
<div class="line">poscar: VASP POSCAR</div>
<div class="line">xyz: Extended XYZ with Lattice information</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.tot_electrons">
<span class="sig-name descname"><span class="pre">tot_electrons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nkpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.tot_electrons" title="Link to this definition"></a></dt>
<dd><p>Total number of electrons</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.unit">
<span class="sig-name descname"><span class="pre">unit</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'angstrom'</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.unit" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.unpack">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moldic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.unpack" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.unpack_">
<span class="sig-name descname"><span class="pre">unpack_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moldic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.unpack_" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.update" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.update_from_chk">
<span class="sig-name descname"><span class="pre">update_from_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.update_from_chk" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.use_loose_rcut">
<span class="sig-name descname"><span class="pre">use_loose_rcut</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.use_loose_rcut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.use_particle_mesh_ewald">
<span class="sig-name descname"><span class="pre">use_particle_mesh_ewald</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.use_particle_mesh_ewald" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.verbose" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.view">
<span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.view" title="Link to this definition"></a></dt>
<dd><p>New view of object with the same attributes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.vol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vol</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.vol" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.with_common_orig">
<span class="sig-name descname"><span class="pre">with_common_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.with_common_orig" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.with_common_origin">
<span class="sig-name descname"><span class="pre">with_common_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.with_common_origin" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.with_integral_screen">
<span class="sig-name descname"><span class="pre">with_integral_screen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.with_integral_screen" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the required integral
screen threshold</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.with_long_range_coulomb">
<span class="sig-name descname"><span class="pre">with_long_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.with_long_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context for long-range part of
range-separated Coulomb operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.with_range_coulomb">
<span class="sig-name descname"><span class="pre">with_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.with_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which sets the required parameter
omega for range-separated Coulomb operator.
If omega = None, return the context for regular Coulomb integrals.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_range_coulomb()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_range_coulomb</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int2e&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.with_rinv_as_nucleus">
<span class="sig-name descname"><span class="pre">with_rinv_as_nucleus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.with_rinv_as_nucleus" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context in which the rinv operator (1/r) is
treated like the Coulomb potential of a Gaussian charge distribution
rho(r) = Norm * exp(-zeta * r^2) at the place of the input atm_id.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_at_nucleus</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.with_rinv_at_nucleus">
<span class="sig-name descname"><span class="pre">with_rinv_at_nucleus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.with_rinv_at_nucleus" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context in which the rinv operator (1/r) is
treated like the Coulomb potential of a Gaussian charge distribution
rho(r) = Norm * exp(-zeta * r^2) at the place of the input atm_id.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_at_nucleus</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.with_rinv_orig">
<span class="sig-name descname"><span class="pre">with_rinv_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.with_rinv_orig" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.with_rinv_origin">
<span class="sig-name descname"><span class="pre">with_rinv_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.with_rinv_origin" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.with_rinv_zeta">
<span class="sig-name descname"><span class="pre">with_rinv_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.with_rinv_zeta" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired Gaussian charge
distribution placed at “rinv_origin”: rho(r) = Norm * exp(-zeta * r^2).
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_zeta()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_zeta</span><span class="p">(</span><span class="n">zeta</span><span class="o">=</span><span class="mf">1.5</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard.with_short_range_coulomb">
<span class="sig-name descname"><span class="pre">with_short_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard.with_short_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context for short-range part of
range-separated Coulomb operator.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.latt.</span></span><span class="sig-name descname"><span class="pre">Hubbard1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsite</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelectron</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hubbard_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hubbard_u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_nn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard1D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard" title="vayesta.lattmod.latt.Hubbard"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hubbard</span></code></a></p>
<p>Hubbard model in 1D.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.dimension">
<span class="sig-name descname"><span class="pre">dimension</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.dimension" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_eri">
<span class="sig-name descname"><span class="pre">get_eri</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hubbard_u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_nn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard1D.get_eri"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_eri" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.lattice_vectors">
<span class="sig-name descname"><span class="pre">lattice_vectors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard1D.lattice_vectors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.lattice_vectors" title="Link to this definition"></a></dt>
<dd><p>Lattice vectors of 1D Hubbard model.</p>
<p>An arbitrary value of 1 A is assumed between sites. The lattice vectors, however, are saved in units of Bohr.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.atom_coords">
<span class="sig-name descname"><span class="pre">atom_coords</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard1D.atom_coords"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.atom_coords" title="Link to this definition"></a></dt>
<dd><p>np.asarray([mol.atom_coord(i) for i in range(mol.natm)])</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_index">
<span class="sig-name descname"><span class="pre">get_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard1D.get_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_index" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.Gv">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Gv</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.Gv" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.ao2mo">
<span class="sig-name descname"><span class="pre">ao2mo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.ao2mo" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.ao_labels">
<span class="sig-name descname"><span class="pre">ao_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.ao_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of AO basis functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>fmt<span class="classifier">str or bool</span></dt><dd><p>if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-AO-notation)]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.ao_loc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ao_loc</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.ao_loc" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start basis function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.ao_loc_2c">
<span class="sig-name descname"><span class="pre">ao_loc_2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.ao_loc_2c" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spinor basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start id of spinor function</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_2c</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 2, 4, 6, 12, 18, 20, 22, 24, 30, 36]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.ao_loc_nr">
<span class="sig-name descname"><span class="pre">ao_loc_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.ao_loc_nr" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start basis function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.ao_rotation_matrix">
<span class="sig-name descname"><span class="pre">ao_rotation_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orientation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.ao_rotation_matrix" title="Link to this definition"></a></dt>
<dd><p>Matrix u to rotate AO basis to a new orientation.</p>
<p>atom_new_coords = mol.atom_coords().dot(orientation.T)
new_AO = u * mol.AO
new_orbitals_coef = u.dot(orbitals_coef)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.aoslice_2c_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_2c_by_atom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.aoslice_2c_by_atom" title="Link to this definition"></a></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.aoslice_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_by_atom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.aoslice_by_atom" title="Link to this definition"></a></dt>
<dd><p>One basis function per site (“atom”).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.aoslice_nr_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_nr_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.aoslice_nr_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.apply" title="Link to this definition"></a></dt>
<dd><p>Apply the fn to rest arguments:  return <code class="docutils literal notranslate"><span class="pre">fn(*args,</span> <span class="pre">**kwargs)</span></code>.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.atom_charge">
<span class="sig-name descname"><span class="pre">atom_charge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.atom_charge" title="Link to this definition"></a></dt>
<dd><p>Nuclear effective charge of the given atom id
Note “atom_charge /= charge(atom_symbol)” when ECP is enabled.
Number of electrons screened by ECP can be obtained by charge(atom_symbol)-atom_charge</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">17</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.atom_charges">
<span class="sig-name descname"><span class="pre">atom_charges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.atom_charges" title="Link to this definition"></a></dt>
<dd><p>np.asarray([mol.atom_charge(i) for i in range(mol.natm)])</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.atom_coord">
<span class="sig-name descname"><span class="pre">atom_coord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Bohr'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.atom_coord" title="Link to this definition"></a></dt>
<dd><p>Coordinates (ndarray) of the given atom id</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.atom_mass_list">
<span class="sig-name descname"><span class="pre">atom_mass_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isotope_avg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.atom_mass_list" title="Link to this definition"></a></dt>
<dd><p>A list of mass for all atoms in the molecule</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>isotope_avg<span class="classifier">boolean</span></dt><dd><p>Whether to use the isotope average mass as the atomic mass</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.atom_nelec_core">
<span class="sig-name descname"><span class="pre">atom_nelec_core</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.atom_nelec_core" title="Link to this definition"></a></dt>
<dd><p>Number of core electrons for pseudo potential.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.atom_nshells">
<span class="sig-name descname"><span class="pre">atom_nshells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.atom_nshells" title="Link to this definition"></a></dt>
<dd><p>Number of basis/shells of the given atom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_nshells</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.atom_pure_symbol">
<span class="sig-name descname"><span class="pre">atom_pure_symbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">site</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.atom_pure_symbol" title="Link to this definition"></a></dt>
<dd><p>For the given atom id, return the standard symbol (striping special characters)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_pure_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.atom_shell_ids">
<span class="sig-name descname"><span class="pre">atom_shell_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.atom_shell_ids" title="Link to this definition"></a></dt>
<dd><p>A list of the shell-ids of the given atom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_shell_ids</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[3, 4, 5, 6, 7]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.atom_symbol">
<span class="sig-name descname"><span class="pre">atom_symbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">site</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.atom_symbol" title="Link to this definition"></a></dt>
<dd><p>For the given atom id, return the input symbol (without striping special characters)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H^2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_angular">
<span class="sig-name descname"><span class="pre">bas_angular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_angular" title="Link to this definition"></a></dt>
<dd><p>The angular momentum associated with the given basis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_angular</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_atom">
<span class="sig-name descname"><span class="pre">bas_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_atom" title="Link to this definition"></a></dt>
<dd><p>The atom (0-based id) that the given basis sits on</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_coord">
<span class="sig-name descname"><span class="pre">bas_coord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_coord" title="Link to this definition"></a></dt>
<dd><p>Coordinates (ndarray) associated with the given basis id</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_ctr_coeff">
<span class="sig-name descname"><span class="pre">bas_ctr_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_ctr_coeff" title="Link to this definition"></a></dt>
<dd><p>Contract coefficients (ndarray) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_ctr_coeff</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[[ 10.03400444]</span>
<span class="go"> [  4.1188704 ]</span>
<span class="go"> [  1.53971186]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_exp">
<span class="sig-name descname"><span class="pre">bas_exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_exp" title="Link to this definition"></a></dt>
<dd><p>exponents (ndarray) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_exp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[ 13.01     1.962    0.4446]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_exps">
<span class="sig-name descname"><span class="pre">bas_exps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_exps" title="Link to this definition"></a></dt>
<dd><p>exponents of all basis
return [mol.bas_exp(i) for i in range(self.nbas)]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_kappa">
<span class="sig-name descname"><span class="pre">bas_kappa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_kappa" title="Link to this definition"></a></dt>
<dd><p>Kappa (if l &lt; j, -l-1, else l) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_kappa</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_len_cart">
<span class="sig-name descname"><span class="pre">bas_len_cart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_len_cart" title="Link to this definition"></a></dt>
<dd><p>The number of Cartesian function associated with given basis</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_len_spinor">
<span class="sig-name descname"><span class="pre">bas_len_spinor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_len_spinor" title="Link to this definition"></a></dt>
<dd><p>The number of spinor associated with given basis
If kappa is 0, return 4l+2</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_nctr">
<span class="sig-name descname"><span class="pre">bas_nctr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_nctr" title="Link to this definition"></a></dt>
<dd><p>The number of contracted GTOs for the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_nctr</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_nprim">
<span class="sig-name descname"><span class="pre">bas_nprim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_nprim" title="Link to this definition"></a></dt>
<dd><p>The number of primitive GTOs for the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_nprim</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.bas_rcut">
<span class="sig-name descname"><span class="pre">bas_rcut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.bas_rcut" title="Link to this definition"></a></dt>
<dd><p>Estimate the largest distance between the function and its image to
reach the precision in overlap</p>
<p>precision ~ int g(r-0) g(r-Rcut)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dump_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parse_arg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_dim_ft_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmorphic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_loose_rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_particle_mesh_ewald</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fractional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.build" title="Link to this definition"></a></dt>
<dd><p>Setup Mole molecule and Cell and initialize some control parameters.
Whenever you change the value of the attributes of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code>,
you need call this function to refresh the internal data of Cell.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>a<span class="classifier">(3,3) ndarray</span></dt><dd><p>The real-space cell lattice vectors. Each row represents
a lattice vector.</p>
</dd>
<dt>fractional<span class="classifier">bool</span></dt><dd><p>Whether the atom postions are specified in fractional coordinates.
The default value is False, which means the coordinates are
interpreted as Cartesian coordinate.</p>
</dd>
<dt>mesh<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>The number of <em>positive</em> G-vectors along each direction.</p>
</dd>
<dt>ke_cutoff<span class="classifier">float</span></dt><dd><p>If set, defines a spherical cutoff of planewaves, with .5 * G**2 &lt; ke_cutoff
The default value is estimated based on <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard1D.precision" title="vayesta.lattmod.latt.Hubbard1D.precision"><code class="xref py py-attr docutils literal notranslate"><span class="pre">precision</span></code></a></p>
</dd>
<dt>precision<span class="classifier">float</span></dt><dd><p>To control Ewald sums and lattice sums accuracy</p>
</dd>
<dt>nimgs<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>Number of repeated images in lattice summation to produce
periodicity. This value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>rcut<span class="classifier">float</span></dt><dd><p>Cutoff radius (unit Bohr) in lattice summation to produce
periodicity. The value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>h<span class="classifier">(3,3) ndarray</span></dt><dd><p>a.T. Deprecated</p>
</dd>
<dt>dimension<span class="classifier">int</span></dt><dd><p>Default is 3</p>
</dd>
<dt>low_dim_ft_type<span class="classifier">str</span></dt><dd><p>For semi-empirical periodic systems, whether to calculate
integrals at the non-PBC dimension using the sampled mesh grids in
infinity vacuum (inf_vacuum) or truncated Coulomb potential
(analytic_2d_1). Unless explicitly specified, analytic_2d_1 is
used for 2D system and inf_vacuum is assumed for 1D and 0D.</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry. Default is False.</p>
</dd>
<dt>symmorphic<span class="classifier">bool</span></dt><dd><p>Whether the lattice is symmorphic. If set to True, even if the
lattice is non-symmorphic, only symmorphic space group symmetry
will be considered. Default is False, meaning the space group is
determined by the lattice symmetry to be symmorphic or non-symmorphic.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.build_lattice_symmetry">
<span class="sig-name descname"><span class="pre">build_lattice_symmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">check_mesh_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.build_lattice_symmetry" title="Link to this definition"></a></dt>
<dd><p>Build cell.lattice_symmetry object.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>check_mesh_symmetry<span class="classifier">bool</span></dt><dd><p>For nonsymmorphic symmetry groups, <cite>cell.mesh</cite> may have
lower symmetry than the lattice. In this case, if
<cite>check_mesh_symmetry</cite> is <cite>True</cite>, the lower symmetry group will
be used. Otherwise, if <cite>check_mesh_symmetry</cite> is <cite>False</cite>,
the mesh grid will be modified to satisfy the higher symmetry.
Default value is <cite>True</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function modifies the attributes of <cite>cell</cite>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.cart">
<span class="sig-name descname"><span class="pre">cart</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.cart" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.cart2sph_coeff">
<span class="sig-name descname"><span class="pre">cart2sph_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sp'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.cart2sph_coeff" title="Link to this definition"></a></dt>
<dd><p>Transformation matrix that transforms Cartesian GTOs to spherical
GTOs for all basis functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>normalized<span class="classifier">string or boolean</span></dt><dd><p>How the Cartesian GTOs are normalized.  Except s and p functions,
Cartesian GTOs do not have the universal normalization coefficients
for the different components of the same shell.  The value of this
argument can be one of ‘sp’, ‘all’, None.  ‘sp’ means the Cartesian s
and p basis are normalized.  ‘all’ means all Cartesian functions are
normalized.  None means none of the Cartesian functions are normalized.
The default value ‘sp’ is the convention used by libcint library.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">cart2sph_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_cart&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">4.58676826646e-15</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.cart_labels">
<span class="sig-name descname"><span class="pre">cart_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.cart_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of Cartesian GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-xyz-notation)]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.charge">
<span class="sig-name descname"><span class="pre">charge</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.charge" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.check_sanity">
<span class="sig-name descname"><span class="pre">check_sanity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.check_sanity" title="Link to this definition"></a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.condense_to_shell">
<span class="sig-name descname"><span class="pre">condense_to_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compressor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'max'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.condense_to_shell" title="Link to this definition"></a></dt>
<dd><p>The given matrix is first partitioned to blocks, based on AO shell as
delimiter. Then call compressor function to abstract each block.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>compressor</strong> – string or function
if compressor is a string, its value can be  sum, max, min, abssum,
absmax, absmin, norm</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.copy" title="Link to this definition"></a></dt>
<dd><p>Deepcopy of the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
<p>Some attributes are shared between the original and copied objects.
Deepcopy is utilized here to ensure that operations on the copied object do
not affect the original object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.cutoff_to_mesh">
<span class="sig-name descname"><span class="pre">cutoff_to_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.cutoff_to_mesh" title="Link to this definition"></a></dt>
<dd><p>Convert KE cutoff to FFT-mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ke_cutoff</strong> – float
KE energy cutoff in a.u.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(3,) array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.decontract_basis">
<span class="sig-name descname"><span class="pre">decontract_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.decontract_basis" title="Link to this definition"></a></dt>
<dd><p>Decontract the basis of a Mole or a Cell.  Returns a Mole (Cell) object
with the uncontracted basis environment and a list of coefficients that
transform the uncontracted basis to the original basis. Each element in
the coefficients list corresponds to one shell of the original Mole (Cell).</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>atoms: list or str</dt><dd><p>Atoms on which the basis to be decontracted. By default, all basis
are decontracted</p>
</dd>
<dt>to_cart: bool</dt><dd><p>Decontract basis and transfer to Cartesian basis</p>
</dd>
<dt>aggregate: bool</dt><dd><p>Whether to aggregate the transformation coefficients into a giant
transformation matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Ne&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmol</span><span class="p">,</span> <span class="n">ctr_coeff</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">decontract_basis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">ctr_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.drop_exponent">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">drop_exponent</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.drop_exponent" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.dump_input">
<span class="sig-name descname"><span class="pre">dump_input</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.dump_input" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.dumps">
<span class="sig-name descname"><span class="pre">dumps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.dumps" title="Link to this definition"></a></dt>
<dd><p>Serialize Cell object to a JSON formatted str.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.elements">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">elements</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.elements" title="Link to this definition"></a></dt>
<dd><p>A list of elements in the molecule</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.energy_nuc">
<span class="sig-name descname"><span class="pre">energy_nuc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.energy_nuc" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.enuc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enuc</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.enuc" title="Link to this definition"></a></dt>
<dd><p>nuclear repulsion energy</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.etbs">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">etbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">etbs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.etbs" title="Link to this definition"></a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard1D.expand_etb" title="vayesta.lattmod.latt.Hubbard1D.expand_etb"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand_etb()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[</strong> (<em>etbs =</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.eval_ao">
<span class="sig-name descname"><span class="pre">eval_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.eval_ao" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.eval_gto">
<span class="sig-name descname"><span class="pre">eval_gto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.eval_gto" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.ew_cut">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ew_cut</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.ew_cut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.ew_eta">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ew_eta</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.ew_eta" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.ewald">
<span class="sig-name descname"><span class="pre">ewald</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.ewald" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.exp_to_discard">
<span class="sig-name descname"><span class="pre">exp_to_discard</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.exp_to_discard" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.expand_etb">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">expand_etb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.expand_etb" title="Link to this definition"></a></dt>
<dd><p>Generate the exponents of even tempered basis for <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code>.
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span>\<span class="n">alpha</span> <span class="o">*</span> \<span class="n">beta</span><span class="o">^</span><span class="p">{</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">}}</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">..</span> <span class="n">n</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l</strong> – int
Angular momentum</p></li>
<li><p><strong>n</strong> – int
Number of GTOs</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[1, [6.0, 1]], [1, [3.0, 1]], [1, [1.5, 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.expand_etbs">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">expand_etbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">etbs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.expand_etbs" title="Link to this definition"></a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard1D.expand_etb" title="vayesta.lattmod.latt.Hubbard1D.expand_etb"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand_etb()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[</strong> (<em>etbs =</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.format_atom">
<span class="sig-name descname"><span class="pre">format_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'angstrom'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.format_atom" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.atom</span></code> to the internal data format.
Including, changing the nuclear charge to atom symbol, converting the
coordinates to AU, rotate and shift the molecule.
If the <code class="xref py py-attr docutils literal notranslate"><span class="pre">atom</span></code> is a string, it takes “;” and “n”
for the mark to separate atoms;  “,” and arbitrary length of blank space
to separate the individual terms for an atom.  Blank line will be ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atoms</strong> – list or str
the same to <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.atom</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>origin<span class="classifier">ndarray</span></dt><dd><p>new axis origin.</p>
</dd>
<dt>axes<span class="classifier">ndarray</span></dt><dd><p>(new_x, new_y, new_z), new coordinates</p>
</dd>
<dt>unit<span class="classifier">str or number</span></dt><dd><p>If unit is one of strings (B, b, Bohr, bohr, AU, au), the coordinates
of the input atoms are the atomic unit;  If unit is one of strings
(A, a, Angstrom, angstrom, Ang, ang), the coordinates are in the
unit of angstrom;  If a number is given, the number are considered
as the Bohr value (in angstrom), which should be around 0.53.
Set unit=1 if wishing to preserve the unit of the coordinates.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl>
<dt>“atoms” in the internal format. The internal format is</dt><dd><div class="line-block">
<div class="line">atom = [[atom1, (x, y, z)],</div>
<div class="line-block">
<div class="line">[atom2, (x, y, z)],</div>
<div class="line">…</div>
<div class="line">[atomN, (x, y, z)]]</div>
</div>
</div>
</dd>
</dl>
</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">(</span><span class="s1">&#39;9,0,0,0; h@1 0 0 1&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H@1&#39;, [-1.0, -1.0, 0.0]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">([</span><span class="s1">&#39;9,0,0,0&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))],</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H&#39;, [-1, -1, 0]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.format_basis">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_tab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.format_basis" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code> to the internal data format.</p>
<dl>
<dt><a href="#id5"><span class="problematic" id="id6">``</span></a>{ atom: [(l, ((-exp, c_1, c_2, ..),</dt><dd><blockquote>
<div><p>(-exp, c_1, c_2, ..))),</p>
</div></blockquote>
<dl class="simple">
<dt>(l, ((-exp, c_1, c_2, ..),</dt><dd><p>(-exp, c_1, c_2, ..)))], … }``</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>basis_tab</strong> – dict
Similar to <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code>, it <strong>cannot</strong> be a str</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="s1">&#39;H^2&#39;</span><span class="p">:</span> <span class="s1">&#39;3-21g&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    [3.4252509099999999, 0.15432897000000001],</span>
<span class="go">    [0.62391373000000006, 0.53532813999999995],</span>
<span class="go">    [0.16885539999999999, 0.44463454000000002]]],</span>
<span class="go"> &#39;H^2&#39;: [[0,</span>
<span class="go">    [5.4471780000000001, 0.15628500000000001],</span>
<span class="go">    [0.82454700000000003, 0.90469100000000002]],</span>
<span class="go">    [0, [0.18319199999999999, 1.0]]]}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;gth-szv&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    (8.3744350009, -0.0283380461),</span>
<span class="go">    (1.8058681460, -0.1333810052),</span>
<span class="go">    (0.4852528328, -0.3995676063),</span>
<span class="go">    (0.1658236932, -0.5531027541)]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.format_ecp">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_ecp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ecp_tab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.format_ecp" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">ecp</span></code> (dict) to the internal data format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span><span class="n">nelec</span><span class="p">,</span>  <span class="c1"># core electrons</span>
</pre></div>
</div>
<blockquote>
<div><blockquote>
<div><dl>
<dt>((l,  # l=-1 for UL, l&gt;=0 for Ul to indicate <a href="#id26"><span class="problematic" id="id27">|l&gt;&lt;l|</span></a></dt><dd><dl>
<dt>(((exp_1, c_1),  # for r^0</dt><dd><blockquote>
<div><p>(exp_2, c_2),
…),</p>
</div></blockquote>
<dl class="simple">
<dt>((exp_1, c_1),  # for r^1</dt><dd><p>(exp_2, c_2),
…),</p>
</dd>
<dt>((exp_1, c_1),  # for r^2</dt><dd><p>…))))),</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>…}</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.format_pseudo">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_pseudo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pseudo_tab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.format_pseudo" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code> (dict) to the internal data format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span> <span class="p">(</span><span class="n">nelec_s</span><span class="p">,</span> <span class="n">nele_p</span><span class="p">,</span> <span class="n">nelec_d</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>
         <span class="n">rloc</span><span class="p">,</span> <span class="n">nexp</span><span class="p">,</span> <span class="p">(</span><span class="n">cexp_1</span><span class="p">,</span> <span class="n">cexp_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">cexp_nexp</span><span class="p">),</span>
         <span class="n">nproj_types</span><span class="p">,</span>
         <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">nproj1</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
                        <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
                        <span class="o">...</span>
                        <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="n">nproj1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="n">nproj1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span>        <span class="p">)</span> <span class="p">)),</span>
         <span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">nproj2</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
         <span class="o">...</span> <span class="p">)</span> <span class="p">)</span>
         <span class="p">)</span>
 <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pseudo_tab</strong> – dict
Similar to <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code> (a dict), it <strong>cannot</strong> be a str</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pbc</span><span class="o">.</span><span class="n">format_pseudo</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;gth-blyp&#39;</span><span class="p">,</span> <span class="s1">&#39;He&#39;</span><span class="p">:</span> <span class="s1">&#39;gth-pade&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[1],</span>
<span class="go">    0.2, 2, [-4.19596147, 0.73049821], 0],</span>
<span class="go"> &#39;He&#39;: [[2],</span>
<span class="go">    0.2, 2, [-9.1120234, 1.69836797], 0]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.fractional">
<span class="sig-name descname"><span class="pre">fractional</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.fractional" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.from_ase">
<span class="sig-name descname"><span class="pre">from_ase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ase_atom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.from_ase" title="Link to this definition"></a></dt>
<dd><p>Update cell based on given ase atom object</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ase.lattice</span><span class="w"> </span><span class="kn">import</span> <span class="n">bulk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">from_ase</span><span class="p">(</span><span class="n">bulk</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">LATTICE_CONST</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.fromfile">
<span class="sig-name descname"><span class="pre">fromfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.fromfile" title="Link to this definition"></a></dt>
<dd><p>Update the Cell object based on the input geometry file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.fromstring">
<span class="sig-name descname"><span class="pre">fromstring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'poscar'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.fromstring" title="Link to this definition"></a></dt>
<dd><p>Update the Cell object based on the input geometry string</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.gen_uniform_grids">
<span class="sig-name descname"><span class="pre">gen_uniform_grids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.gen_uniform_grids" title="Link to this definition"></a></dt>
<dd><p>Generate a uniform real-space grid consistent w/ samp thm; see MH (3.19).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngx*ngy*ngz, 3) ndarray</dt><dd><p>The real-space grid point coordinates.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>coords</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_Gv">
<span class="sig-name descname"><span class="pre">get_Gv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_Gv" title="Link to this definition"></a></dt>
<dd><p>Calculate three-dimensional G-vectors for the cell; see MH (3.8).</p>
<p>Indices along each direction go as [0…N-1, -N…-1] to follow FFT convention.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngrids, 3) ndarray of floats</dt><dd><p>The array of G-vectors.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Gv</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_Gv_weights">
<span class="sig-name descname"><span class="pre">get_Gv_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_Gv_weights" title="Link to this definition"></a></dt>
<dd><p>Calculate G-vectors and weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>(ngris, 3) ndarray of floats</dt><dd><p>The array of G-vectors.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Gv</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_SI">
<span class="sig-name descname"><span class="pre">get_SI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Gv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmlst</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_SI" title="Link to this definition"></a></dt>
<dd><p>Calculate the structure factor (0D, 1D, 2D, 3D) for all atoms; see MH (3.34).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p></li>
<li><p><strong>Gv</strong> – (N,3) array
G vectors</p></li>
<li><p><strong>atmlst</strong> – list of ints, optional
Indices of atoms for which the structure factors are computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(natm, ngrids) ndarray, dtype=np.complex128</dt><dd><p>The structure factor for each atom at each G-vector.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SI</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_abs_kpts">
<span class="sig-name descname"><span class="pre">get_abs_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scaled_kpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_abs_kpts" title="Link to this definition"></a></dt>
<dd><p>Get absolute k-points (in 1/Bohr), given “scaled” k-points in
fractions of lattice vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>scaled_kpts</strong> – (nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>abs_kpts</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_ao_indices">
<span class="sig-name descname"><span class="pre">get_ao_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_ao_indices" title="Link to this definition"></a></dt>
<dd><p>Generate (dis-continued) AO indices for basis specified in bas_list</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_bounding_sphere">
<span class="sig-name descname"><span class="pre">get_bounding_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rcut</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_bounding_sphere" title="Link to this definition"></a></dt>
<dd><p>Finds all the lattice points within a sphere of radius rcut.</p>
<p>Defines a parallelepiped given by -N_x &lt;= n_x &lt;= N_x, with x in [1,3]
See Martin p. 85</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rcut</strong> – number
real space cut-off for interaction</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray of 3 ints defining N_x</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>cut</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_enuc">
<span class="sig-name descname"><span class="pre">get_enuc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_enuc" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_ewald_params">
<span class="sig-name descname"><span class="pre">get_ewald_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_ewald_params" title="Link to this definition"></a></dt>
<dd><p>Choose a reasonable value of Ewald ‘eta’ and ‘cut’ parameters.
eta^2 is the exponent coefficient of the model Gaussian charge for nucleus
at R:  frac{eta^3}{pi^1.5} e^{-eta^2 (r-R)^2}</p>
<p>Choice is based on largest G vector and desired relative precision.</p>
<p>The relative error in the G-space sum is given by</p>
<blockquote>
<div><p>precision ~ 4pi Gmax^2 e^{(-Gmax^2)/(4 eta^2)}</p>
</div></blockquote>
<p>which determines eta. Then, real-space cutoff is determined by (exp.
factors only)</p>
<blockquote>
<div><p>precision ~ erfc(eta*rcut) / rcut ~ e^{(-eta**2 rcut*2)}</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald ‘eta’ and ‘cut’ parameters.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ew_eta, ew_cut</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_kpts">
<span class="sig-name descname"><span class="pre">get_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_gamma_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_reversal_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_kpts" title="Link to this definition"></a></dt>
<dd><p>Given number of kpoints along x,y,z , generate kpoints</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nks</strong> – (3,) ndarray</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>wrap_around<span class="classifier">bool</span></dt><dd><p>To ensure all kpts are in first Brillouin zone.</p>
</dd>
<dt>with_gamma_point<span class="classifier">bool</span></dt><dd><p>Whether to shift Monkhorst-pack grid to include gamma-point.</p>
</dd>
<dt>scaled_center<span class="classifier">(3,) array</span></dt><dd><p>Shift all points in the Monkhorst-pack grid to be centered on
scaled_center, given as the zeroth index of the returned kpts.
Scaled meaning that the k-points are scaled to a grid from
[-1,1] x [-1,1] x [-1,1]</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry</p>
</dd>
<dt>time_reversal_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider time reversal symmetry</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>kpts in absolute value (unit 1/Bohr).  Gamma point is placed at the
first place in the k-points list;
instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> if k-point symmetry is considered</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_lattice_Ls">
<span class="sig-name descname"><span class="pre">get_lattice_Ls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_lattice_Ls" title="Link to this definition"></a></dt>
<dd><p>Get the (Cartesian, unitful) lattice translation vectors for nearby images.
The translation vectors can be used for the lattice summation.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>discard:</dt><dd><p>Drop less important Ls based on AO values on grid</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_nimgs">
<span class="sig-name descname"><span class="pre">get_nimgs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_nimgs" title="Link to this definition"></a></dt>
<dd><p>Choose number of basis function images in lattice sums
to include for given precision in overlap, using</p>
<p>precision ~ int r^l e^{-alpha r^2} (r-rcut)^l e^{-alpha (r-rcut)^2}
~ (rcut^2/(2alpha))^l e^{alpha/2 rcut^2}</p>
<p>where alpha is the smallest exponent in the basis. Note
that assumes an isolated exponent in the middle of the box, so
it adds one additional lattice vector to be safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_overlap_cond">
<span class="sig-name descname"><span class="pre">get_overlap_cond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_overlap_cond" title="Link to this definition"></a></dt>
<dd><p>Overlap magnitudes measured by -log(overlap) between two shells</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>2D mask array of shape (nbas,nbas)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_scaled_atom_coords">
<span class="sig-name descname"><span class="pre">get_scaled_atom_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_scaled_atom_coords" title="Link to this definition"></a></dt>
<dd><p>Get scaled atomic coordinates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_scaled_kpts">
<span class="sig-name descname"><span class="pre">get_scaled_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">abs_kpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts_in_ibz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_scaled_kpts" title="Link to this definition"></a></dt>
<dd><p>Get scaled k-points, given absolute k-points in 1/Bohr.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>abs_kpts</strong> – (nkpts, 3) ndarray of floats or <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> object</p></li>
<li><p><strong>kpts_in_ibz</strong> – bool
If True, return k-points in IBZ; otherwise, return k-points in BZ.
Default value is True. This has effects only if abs_kpts is a
<code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>scaled_kpts</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.get_uniform_grids">
<span class="sig-name descname"><span class="pre">get_uniform_grids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.get_uniform_grids" title="Link to this definition"></a></dt>
<dd><p>Generate a uniform real-space grid consistent w/ samp thm; see MH (3.19).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngx*ngy*ngz, 3) ndarray</dt><dd><p>The real-space grid point coordinates.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>coords</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.gs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gs</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.gs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.gto_norm">
<span class="sig-name descname"><span class="pre">gto_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expnt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.gto_norm" title="Link to this definition"></a></dt>
<dd><p>Normalized factor for GTO radial part   <span class="math notranslate nohighlight">\(g=r^l e^{-\alpha r^2}\)</span></p>
<div class="math notranslate nohighlight">
\[\frac{1}{\sqrt{\int g^2 r^2 dr}}
= \sqrt{\frac{2^{2l+3} (l+1)! (2a)^{l+1.5}}{(2l+2)!\sqrt{\pi}}}\]</div>
<p>Ref: H. B. Schlegel and M. J. Frisch, Int. J. Quant.  Chem., 54(1995), 83-87.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l</strong> (<em>int</em>) – angular momentum</p></li>
<li><p><strong>expnt</strong> – exponent <span class="math notranslate nohighlight">\(\alpha\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>normalization factor</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gto_norm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">2.5264751109842591</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.h">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">h</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.h" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.has_ecp">
<span class="sig-name descname"><span class="pre">has_ecp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.has_ecp" title="Link to this definition"></a></dt>
<dd><p>Whether pseudo potential is used in the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.has_ecp_soc">
<span class="sig-name descname"><span class="pre">has_ecp_soc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.has_ecp_soc" title="Link to this definition"></a></dt>
<dd><p>Whether spin-orbit coupling is enabled in ECP.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.incore_anyway">
<span class="sig-name descname"><span class="pre">incore_anyway</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.incore_anyway" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.intor">
<span class="sig-name descname"><span class="pre">intor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s1'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.intor" title="Link to this definition"></a></dt>
<dd><p>Integral generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1e or 2e AO integrals.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Symmetry of the integrals</p>
<div class="line-block">
<div class="line">0 : no symmetry assumed (default)</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>shls_slice<span class="classifier">4-element, 6-element or 8-element tuple</span></dt><dd><p>Label the start-stop shells for each index in the integral.
For example, the 8-element tuple for the 2-electron integral
tensor (ij|kl) = intor(‘int2e’) are specified as
(ish_start, ish_end, jsh_start, jsh_end, ksh_start, ksh_end, lsh_start, lsh_end)</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ipnuc_sph&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># &lt;nabla i | V_nuc | j&gt;</span>
<span class="go">[[[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.10289944  0.48176097]</span>
<span class="go">  [-0.48176097 -0.10289944]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.intor_asymmetric">
<span class="sig-name descname"><span class="pre">intor_asymmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.intor_asymmetric" title="Link to this definition"></a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be anti-hermitian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp has 3 components.</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_asymmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j  0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j  0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.intor_by_shell">
<span class="sig-name descname"><span class="pre">intor_by_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.intor_by_shell" title="Link to this definition"></a></dt>
<dd><p>For given 2, 3 or 4 shells, interface for libcint to get 1e, 2e,
2-center-2e or 3-center-2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>intor_name</strong> – str
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the supported intor_name</p></li>
<li><p><strong>shls</strong> – list of int
The AO shell-ids of the integrals</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp has 3 components.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 2-dim to 5-dim, depending on the integral type (1e,
2e, 3c-2e, 2c2e) and the value of comp</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The gradients of the spherical 2e integrals</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">getints_by_shell</span><span class="p">(</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[[[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.08760462]]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.intor_symmetric">
<span class="sig-name descname"><span class="pre">intor_symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.intor_symmetric" title="Link to this definition"></a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be hermitian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_symmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.kernel">
<span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dump_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parse_arg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_dim_ft_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmorphic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_loose_rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_particle_mesh_ewald</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fractional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.kernel" title="Link to this definition"></a></dt>
<dd><p>Setup Mole molecule and Cell and initialize some control parameters.
Whenever you change the value of the attributes of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code>,
you need call this function to refresh the internal data of Cell.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>a<span class="classifier">(3,3) ndarray</span></dt><dd><p>The real-space cell lattice vectors. Each row represents
a lattice vector.</p>
</dd>
<dt>fractional<span class="classifier">bool</span></dt><dd><p>Whether the atom postions are specified in fractional coordinates.
The default value is False, which means the coordinates are
interpreted as Cartesian coordinate.</p>
</dd>
<dt>mesh<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>The number of <em>positive</em> G-vectors along each direction.</p>
</dd>
<dt>ke_cutoff<span class="classifier">float</span></dt><dd><p>If set, defines a spherical cutoff of planewaves, with .5 * G**2 &lt; ke_cutoff
The default value is estimated based on <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard1D.precision" title="vayesta.lattmod.latt.Hubbard1D.precision"><code class="xref py py-attr docutils literal notranslate"><span class="pre">precision</span></code></a></p>
</dd>
<dt>precision<span class="classifier">float</span></dt><dd><p>To control Ewald sums and lattice sums accuracy</p>
</dd>
<dt>nimgs<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>Number of repeated images in lattice summation to produce
periodicity. This value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>rcut<span class="classifier">float</span></dt><dd><p>Cutoff radius (unit Bohr) in lattice summation to produce
periodicity. The value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>h<span class="classifier">(3,3) ndarray</span></dt><dd><p>a.T. Deprecated</p>
</dd>
<dt>dimension<span class="classifier">int</span></dt><dd><p>Default is 3</p>
</dd>
<dt>low_dim_ft_type<span class="classifier">str</span></dt><dd><p>For semi-empirical periodic systems, whether to calculate
integrals at the non-PBC dimension using the sampled mesh grids in
infinity vacuum (inf_vacuum) or truncated Coulomb potential
(analytic_2d_1). Unless explicitly specified, analytic_2d_1 is
used for 2D system and inf_vacuum is assumed for 1D and 0D.</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry. Default is False.</p>
</dd>
<dt>symmorphic<span class="classifier">bool</span></dt><dd><p>Whether the lattice is symmorphic. If set to True, even if the
lattice is non-symmorphic, only symmorphic space group symmetry
will be considered. Default is False, meaning the space group is
determined by the lattice symmetry to be symmorphic or non-symmorphic.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.lattice_symmetry">
<span class="sig-name descname"><span class="pre">lattice_symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.lattice_symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.loads">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molstr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.loads" title="Link to this definition"></a></dt>
<dd><p>Deserialize a str containing a JSON document to a Cell object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.loads_">
<span class="sig-name descname"><span class="pre">loads_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molstr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.loads_" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.low_dim_ft_type">
<span class="sig-name descname"><span class="pre">low_dim_ft_type</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.low_dim_ft_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.make_atm_env">
<span class="sig-name descname"><span class="pre">make_atm_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucmod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucprop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.make_atm_env" title="Link to this definition"></a></dt>
<dd><p>Convert the internal format <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._atom</span></code> to the format required
by <code class="docutils literal notranslate"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.make_bas_env">
<span class="sig-name descname"><span class="pre">make_bas_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_add</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.make_bas_env" title="Link to this definition"></a></dt>
<dd><p>Convert <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code> to the argument <code class="docutils literal notranslate"><span class="pre">bas</span></code> for <code class="docutils literal notranslate"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.make_ecp_env">
<span class="sig-name descname"><span class="pre">make_ecp_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_atm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_ecp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.make_ecp_env" title="Link to this definition"></a></dt>
<dd><p>Generate the input arguments _ecpbas for ECP integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.make_env">
<span class="sig-name descname"><span class="pre">make_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucmod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucprop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.make_env" title="Link to this definition"></a></dt>
<dd><p>Generate the input arguments for <code class="docutils literal notranslate"><span class="pre">libcint</span></code> library based on internal
format <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._atom</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._basis</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.make_kpts">
<span class="sig-name descname"><span class="pre">make_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_gamma_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_reversal_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.make_kpts" title="Link to this definition"></a></dt>
<dd><p>Given number of kpoints along x,y,z , generate kpoints</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nks</strong> – (3,) ndarray</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>wrap_around<span class="classifier">bool</span></dt><dd><p>To ensure all kpts are in first Brillouin zone.</p>
</dd>
<dt>with_gamma_point<span class="classifier">bool</span></dt><dd><p>Whether to shift Monkhorst-pack grid to include gamma-point.</p>
</dd>
<dt>scaled_center<span class="classifier">(3,) array</span></dt><dd><p>Shift all points in the Monkhorst-pack grid to be centered on
scaled_center, given as the zeroth index of the returned kpts.
Scaled meaning that the k-points are scaled to a grid from
[-1,1] x [-1,1] x [-1,1]</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry</p>
</dd>
<dt>time_reversal_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider time reversal symmetry</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>kpts in absolute value (unit 1/Bohr).  Gamma point is placed at the
first place in the k-points list;
instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> if k-point symmetry is considered</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.max_memory">
<span class="sig-name descname"><span class="pre">max_memory</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4000</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.max_memory" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.mesh">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mesh</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.mesh" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.ms">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ms</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.ms" title="Link to this definition"></a></dt>
<dd><p>Spin quantum number. multiplicity = ms*2+1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.multiplicity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">multiplicity</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.multiplicity" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.nao">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nao</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.nao" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.nao_2c">
<span class="sig-name descname"><span class="pre">nao_2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.nao_2c" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted spinor GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.nao_2c_range">
<span class="sig-name descname"><span class="pre">nao_2c_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bas_id1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.nao_2c_range" title="Link to this definition"></a></dt>
<dd><p>Lower and upper boundary of contracted spinor basis functions associated
with the given shell range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p></li>
<li><p><strong>bas_id0</strong> – int
start shell id, 0-based</p></li>
<li><p><strong>bas_id1</strong> – int
stop shell id, 0-based</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple of start basis function id and the stop function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_2c_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(4, 12)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.nao_cart">
<span class="sig-name descname"><span class="pre">nao_cart</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.nao_cart" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted cartesian GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.nao_nr">
<span class="sig-name descname"><span class="pre">nao_nr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.nao_nr" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.nao_nr_range">
<span class="sig-name descname"><span class="pre">nao_nr_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bas_id1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.nao_nr_range" title="Link to this definition"></a></dt>
<dd><p>Lower and upper boundary of contracted spherical basis functions associated
with the given shell range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p></li>
<li><p><strong>bas_id0</strong> – int
start shell id</p></li>
<li><p><strong>bas_id1</strong> – int
stop shell id</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple of start basis function id and the stop function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_nr_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(2, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.natm">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">natm</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.natm" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.nbas">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nbas</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.nbas" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.nelec">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.nelec" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.nelectron">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelectron</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.nelectron" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.nimgs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nimgs</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.nimgs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.npgto_nr">
<span class="sig-name descname"><span class="pre">npgto_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.npgto_nr" title="Link to this definition"></a></dt>
<dd><p>Total number of primitive spherical GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.offset_2c_by_atom">
<span class="sig-name descname"><span class="pre">offset_2c_by_atom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.offset_2c_by_atom" title="Link to this definition"></a></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.offset_ao_by_atom">
<span class="sig-name descname"><span class="pre">offset_ao_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.offset_ao_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.offset_nr_by_atom">
<span class="sig-name descname"><span class="pre">offset_nr_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.offset_nr_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.omega">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">omega</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.omega" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.output">
<span class="sig-name descname"><span class="pre">output</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.output" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.pack">
<span class="sig-name descname"><span class="pre">pack</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.pack" title="Link to this definition"></a></dt>
<dd><p>Pack the input args of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> to a dict, which can be serialized
with <code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.pbc_eval_ao">
<span class="sig-name descname"><span class="pre">pbc_eval_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.pbc_eval_ao" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.pbc_eval_gto">
<span class="sig-name descname"><span class="pre">pbc_eval_gto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.pbc_eval_gto" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.pbc_intor">
<span class="sig-name descname"><span class="pre">pbc_intor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.pbc_intor" title="Link to this definition"></a></dt>
<dd><p>One-electron integrals with PBC.</p>
<div class="math notranslate nohighlight">
\[\sum_T \int \mu(r) * [intor] * \nu (r-T) dr\]</div>
<p>See also Mole.intor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.post_kernel">
<span class="sig-name descname"><span class="pre">post_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.post_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run after the main body of the kernel function.  Internal
variables are exposed to post_kernel through the “envs” dictionary.
Return value of post_kernel function is not required.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.pre_kernel">
<span class="sig-name descname"><span class="pre">pre_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.pre_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run before the main body of kernel function is executed.
Internal variables are exposed to pre_kernel through the “envs”
dictionary.  Return value of pre_kernel function is not required.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.precision">
<span class="sig-name descname"><span class="pre">precision</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-08</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.precision" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.rcut">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rcut</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.rcut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.rcut_by_shells">
<span class="sig-name descname"><span class="pre">rcut_by_shells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_pgf_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.rcut_by_shells" title="Link to this definition"></a></dt>
<dd><p>Compute shell and primitive gaussian function radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.reciprocal_vectors">
<span class="sig-name descname"><span class="pre">reciprocal_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.283185307179586</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.reciprocal_vectors" title="Link to this definition"></a></dt>
<dd><div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\mathbf{b_1} &amp;= 2\pi \frac{\mathbf{a_2} \times \mathbf{a_3}}{\mathbf{a_1} \cdot (\mathbf{a_2} \times \mathbf{a_3})} \\
\mathbf{b_2} &amp;= 2\pi \frac{\mathbf{a_3} \times \mathbf{a_1}}{\mathbf{a_2} \cdot (\mathbf{a_3} \times \mathbf{a_1})} \\
\mathbf{b_3} &amp;= 2\pi \frac{\mathbf{a_1} \times \mathbf{a_2}}{\mathbf{a_3} \cdot (\mathbf{a_1} \times \mathbf{a_2})}
\end{align}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.reset" title="Link to this definition"></a></dt>
<dd><p>Clean up intermediates</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.run" title="Link to this definition"></a></dt>
<dd><p>Call the kernel function of current object.  <cite>args</cite> will be passed
to kernel function.  <cite>kwargs</cite> will be used to update the attributes of
current object.  The return value of method run is the object itself.
This allows a series of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.search_ao_label">
<span class="sig-name descname"><span class="pre">search_ao_label</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.search_ao_label" title="Link to this definition"></a></dt>
<dd><p>Find the index of the AO basis function based on the given ao_label</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ao_label</strong> – string or a list of strings
The regular expression pattern to match the orbital labels
returned by mol.ao_labels()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of index for the AOs that matches the given ao_label RE pattern</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl.*p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21 22 23 24 25 26 27 28 29 30]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl 2p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">([</span><span class="s1">&#39;Cl.*d&#39;</span><span class="p">,</span> <span class="s1">&#39;Cl 4p&#39;</span><span class="p">])</span>
<span class="go">[25 26 27 31 32 33 34 35 36 37 38 39 40]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.search_ao_nr">
<span class="sig-name descname"><span class="pre">search_ao_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmshell</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.search_ao_nr" title="Link to this definition"></a></dt>
<dd><p>Search the first basis function id (<strong>not</strong> the shell id) which matches
the given atom-id, angular momentum magnetic angular momentum, principal shell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atm_id</strong> – int
atom id, 0-based</p></li>
<li><p><strong>l</strong> – int
angular momentum</p></li>
<li><p><strong>m</strong> – int
magnetic angular momentum</p></li>
<li><p><strong>atmshell</strong> – int
principal quantum number</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>basis function id, 0-based.  If not found, return None</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_nr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Cl 3px</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.search_ao_r">
<span class="sig-name descname"><span class="pre">search_ao_r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmshell</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.search_ao_r" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.search_shell_id">
<span class="sig-name descname"><span class="pre">search_shell_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.search_shell_id" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set" title="Link to this definition"></a></dt>
<dd><p>Update the attributes of the current object.  The return value of
method set is the object itself.  This allows a series of
functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_common_orig">
<span class="sig-name descname"><span class="pre">set_common_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_common_orig" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_common_orig_">
<span class="sig-name descname"><span class="pre">set_common_orig_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_common_orig_" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_common_origin">
<span class="sig-name descname"><span class="pre">set_common_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_common_origin" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_common_origin_">
<span class="sig-name descname"><span class="pre">set_common_origin_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_common_origin_" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_f12_zeta">
<span class="sig-name descname"><span class="pre">set_f12_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_f12_zeta" title="Link to this definition"></a></dt>
<dd><p>Set zeta for YP exp(-zeta r12)/r12 or STG exp(-zeta r12) type integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_geom_">
<span class="sig-name descname"><span class="pre">set_geom_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms_or_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_geom_" title="Link to this definition"></a></dt>
<dd><p>Update geometry</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_nuc_mod">
<span class="sig-name descname"><span class="pre">set_nuc_mod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_nuc_mod" title="Link to this definition"></a></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_nuc_mod_">
<span class="sig-name descname"><span class="pre">set_nuc_mod_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_nuc_mod_" title="Link to this definition"></a></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_range_coulomb">
<span class="sig-name descname"><span class="pre">set_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Switch on range-separated Coulomb operator for <strong>all</strong> 2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>omega</strong> – <p>double</p>
<div class="line-block">
<div class="line">= 0 : Regular electron repulsion integral</div>
<div class="line">&gt; 0 : Long-range operator  erf(omega r12) / r12</div>
<div class="line">&lt; 0 : Short-range operator  erfc(omega r12) /r12</div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_range_coulomb_">
<span class="sig-name descname"><span class="pre">set_range_coulomb_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_range_coulomb_" title="Link to this definition"></a></dt>
<dd><p>Switch on range-separated Coulomb operator for <strong>all</strong> 2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>omega</strong> – <p>double</p>
<div class="line-block">
<div class="line">= 0 : Regular electron repulsion integral</div>
<div class="line">&gt; 0 : Long-range operator  erf(omega r12) / r12</div>
<div class="line">&lt; 0 : Short-range operator  erfc(omega r12) /r12</div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_rinv_orig">
<span class="sig-name descname"><span class="pre">set_rinv_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_rinv_orig" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_rinv_orig_">
<span class="sig-name descname"><span class="pre">set_rinv_orig_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_rinv_orig_" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_rinv_origin">
<span class="sig-name descname"><span class="pre">set_rinv_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_rinv_origin" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_rinv_origin_">
<span class="sig-name descname"><span class="pre">set_rinv_origin_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_rinv_origin_" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_rinv_zeta">
<span class="sig-name descname"><span class="pre">set_rinv_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_rinv_zeta" title="Link to this definition"></a></dt>
<dd><p>Assume the charge distribution on the “rinv_origin”.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.set_rinv_zeta_">
<span class="sig-name descname"><span class="pre">set_rinv_zeta_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.set_rinv_zeta_" title="Link to this definition"></a></dt>
<dd><p>Assume the charge distribution on the “rinv_origin”.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.space_group_symmetry">
<span class="sig-name descname"><span class="pre">space_group_symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.space_group_symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.sph2spinor_coeff">
<span class="sig-name descname"><span class="pre">sph2spinor_coeff</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.sph2spinor_coeff" title="Link to this definition"></a></dt>
<dd><p>Transformation matrix that transforms real-spherical GTOs to spinor
GTOs for all basis functions</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca</span><span class="p">,</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">sph2spinor_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_spinor&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ca</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">+=</span> <span class="n">cb</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">6.66133814775e-16</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.sph_labels">
<span class="sig-name descname"><span class="pre">sph_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.sph_labels" title="Link to this definition"></a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.spheric_labels">
<span class="sig-name descname"><span class="pre">spheric_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.spheric_labels" title="Link to this definition"></a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.spin">
<span class="sig-name descname"><span class="pre">spin</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.spin" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.spinor_labels">
<span class="sig-name descname"><span class="pre">spinor_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.spinor_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of spinor GTO functions</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.stdout">
<span class="sig-name descname"><span class="pre">stdout</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.stdout" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.symmetrize_mesh">
<span class="sig-name descname"><span class="pre">symmetrize_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.symmetrize_mesh" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.symmetry">
<span class="sig-name descname"><span class="pre">symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.symmetry_subgroup">
<span class="sig-name descname"><span class="pre">symmetry_subgroup</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.symmetry_subgroup" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.symmorphic">
<span class="sig-name descname"><span class="pre">symmorphic</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.symmorphic" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.time_reversal_map">
<span class="sig-name descname"><span class="pre">time_reversal_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.time_reversal_map" title="Link to this definition"></a></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have positive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math notranslate nohighlight">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math notranslate nohighlight">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.tmap">
<span class="sig-name descname"><span class="pre">tmap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.tmap" title="Link to this definition"></a></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have positive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math notranslate nohighlight">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math notranslate nohighlight">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.to_mol">
<span class="sig-name descname"><span class="pre">to_mol</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.to_mol" title="Link to this definition"></a></dt>
<dd><p>Return a Mole object using the same atoms and basis functions as
the Cell object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.to_uncontracted_cartesian_basis">
<span class="sig-name descname"><span class="pre">to_uncontracted_cartesian_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.to_uncontracted_cartesian_basis" title="Link to this definition"></a></dt>
<dd><p>Decontract the basis of a Mole or a Cell.  Returns a Mole (Cell) object
with uncontracted Cartesian basis and a list of coefficients that
transform the uncontracted basis to the original basis. Each element in
the coefficients list corresponds to one shell of the original Mole (Cell).</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Ne&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmol</span><span class="p">,</span> <span class="n">ctr_coeff</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">to_uncontracted_cartesian_basis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">ctr_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.tofile">
<span class="sig-name descname"><span class="pre">tofile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.tofile" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.tostring">
<span class="sig-name descname"><span class="pre">tostring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'poscar'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.tostring" title="Link to this definition"></a></dt>
<dd><p>Convert cell geometry to a string of the required format.</p>
<dl>
<dt>Supported output formats:</dt><dd><div class="line-block">
<div class="line">poscar: VASP POSCAR</div>
<div class="line">xyz: Extended XYZ with Lattice information</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.tot_electrons">
<span class="sig-name descname"><span class="pre">tot_electrons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nkpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.tot_electrons" title="Link to this definition"></a></dt>
<dd><p>Total number of electrons</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.unit">
<span class="sig-name descname"><span class="pre">unit</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'angstrom'</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.unit" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.unpack">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moldic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.unpack" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.unpack_">
<span class="sig-name descname"><span class="pre">unpack_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moldic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.unpack_" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.update" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.update_from_chk">
<span class="sig-name descname"><span class="pre">update_from_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.update_from_chk" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.use_loose_rcut">
<span class="sig-name descname"><span class="pre">use_loose_rcut</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.use_loose_rcut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.use_particle_mesh_ewald">
<span class="sig-name descname"><span class="pre">use_particle_mesh_ewald</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.use_particle_mesh_ewald" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.verbose" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.view">
<span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.view" title="Link to this definition"></a></dt>
<dd><p>New view of object with the same attributes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.vol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vol</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.vol" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.with_common_orig">
<span class="sig-name descname"><span class="pre">with_common_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.with_common_orig" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.with_common_origin">
<span class="sig-name descname"><span class="pre">with_common_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.with_common_origin" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.with_integral_screen">
<span class="sig-name descname"><span class="pre">with_integral_screen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.with_integral_screen" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the required integral
screen threshold</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.with_long_range_coulomb">
<span class="sig-name descname"><span class="pre">with_long_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.with_long_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context for long-range part of
range-separated Coulomb operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.with_range_coulomb">
<span class="sig-name descname"><span class="pre">with_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.with_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which sets the required parameter
omega for range-separated Coulomb operator.
If omega = None, return the context for regular Coulomb integrals.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_range_coulomb()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_range_coulomb</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int2e&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.with_rinv_as_nucleus">
<span class="sig-name descname"><span class="pre">with_rinv_as_nucleus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.with_rinv_as_nucleus" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context in which the rinv operator (1/r) is
treated like the Coulomb potential of a Gaussian charge distribution
rho(r) = Norm * exp(-zeta * r^2) at the place of the input atm_id.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_at_nucleus</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.with_rinv_at_nucleus">
<span class="sig-name descname"><span class="pre">with_rinv_at_nucleus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.with_rinv_at_nucleus" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context in which the rinv operator (1/r) is
treated like the Coulomb potential of a Gaussian charge distribution
rho(r) = Norm * exp(-zeta * r^2) at the place of the input atm_id.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_at_nucleus</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.with_rinv_orig">
<span class="sig-name descname"><span class="pre">with_rinv_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.with_rinv_orig" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.with_rinv_origin">
<span class="sig-name descname"><span class="pre">with_rinv_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.with_rinv_origin" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.with_rinv_zeta">
<span class="sig-name descname"><span class="pre">with_rinv_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.with_rinv_zeta" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired Gaussian charge
distribution placed at “rinv_origin”: rho(r) = Norm * exp(-zeta * r^2).
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_zeta()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_zeta</span><span class="p">(</span><span class="n">zeta</span><span class="o">=</span><span class="mf">1.5</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard1D.with_short_range_coulomb">
<span class="sig-name descname"><span class="pre">with_short_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard1D.with_short_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context for short-range part of
range-separated Coulomb operator.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.latt.</span></span><span class="sig-name descname"><span class="pre">Hubbard2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsites</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nelectron</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hubbard_t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hubbard_u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tiles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard2D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard" title="vayesta.lattmod.latt.Hubbard"><code class="xref py py-class docutils literal notranslate"><span class="pre">Hubbard</span></code></a></p>
<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.dimension">
<span class="sig-name descname"><span class="pre">dimension</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.dimension" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_index">
<span class="sig-name descname"><span class="pre">get_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard2D.get_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_index" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_eri">
<span class="sig-name descname"><span class="pre">get_eri</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hubbard_u</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_nn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard2D.get_eri"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_eri" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.lattice_vectors">
<span class="sig-name descname"><span class="pre">lattice_vectors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard2D.lattice_vectors"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.lattice_vectors" title="Link to this definition"></a></dt>
<dd><p>Lattice vectors of 1D Hubbard model.</p>
<p>An arbitrary value of 1 A is assumed between sites. The lattice vectors, however, are saved in units of Bohr.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.atom_coords">
<span class="sig-name descname"><span class="pre">atom_coords</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard2D.atom_coords"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.atom_coords" title="Link to this definition"></a></dt>
<dd><p>Sites are ordered by default as:</p>
<p>6 7 8
3 4 5
0 1 2</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_tiles_order">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_tiles_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nsites</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tiles</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#Hubbard2D.get_tiles_order"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_tiles_order" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.Gv">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Gv</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.Gv" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.ao2mo">
<span class="sig-name descname"><span class="pre">ao2mo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeffs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.ao2mo" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.ao_labels">
<span class="sig-name descname"><span class="pre">ao_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.ao_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of AO basis functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>fmt<span class="classifier">str or bool</span></dt><dd><p>if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-AO-notation)]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.ao_loc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ao_loc</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.ao_loc" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start basis function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.ao_loc_2c">
<span class="sig-name descname"><span class="pre">ao_loc_2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.ao_loc_2c" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spinor basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start id of spinor function</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_2c</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 2, 4, 6, 12, 18, 20, 22, 24, 30, 36]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.ao_loc_nr">
<span class="sig-name descname"><span class="pre">ao_loc_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.ao_loc_nr" title="Link to this definition"></a></dt>
<dd><p>Offset of every shell in the spherical basis function spectrum</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, each entry is the corresponding start basis function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">ao_loc_nr</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 6, 9, 10, 11, 12, 15, 18]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.ao_rotation_matrix">
<span class="sig-name descname"><span class="pre">ao_rotation_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orientation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.ao_rotation_matrix" title="Link to this definition"></a></dt>
<dd><p>Matrix u to rotate AO basis to a new orientation.</p>
<p>atom_new_coords = mol.atom_coords().dot(orientation.T)
new_AO = u * mol.AO
new_orbitals_coef = u.dot(orbitals_coef)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.aoslice_2c_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_2c_by_atom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.aoslice_2c_by_atom" title="Link to this definition"></a></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.aoslice_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_by_atom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.aoslice_by_atom" title="Link to this definition"></a></dt>
<dd><p>One basis function per site (“atom”).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.aoslice_nr_by_atom">
<span class="sig-name descname"><span class="pre">aoslice_nr_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.aoslice_nr_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.apply" title="Link to this definition"></a></dt>
<dd><p>Apply the fn to rest arguments:  return <code class="docutils literal notranslate"><span class="pre">fn(*args,</span> <span class="pre">**kwargs)</span></code>.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.atom_charge">
<span class="sig-name descname"><span class="pre">atom_charge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.atom_charge" title="Link to this definition"></a></dt>
<dd><p>Nuclear effective charge of the given atom id
Note “atom_charge /= charge(atom_symbol)” when ECP is enabled.
Number of electrons screened by ECP can be obtained by charge(atom_symbol)-atom_charge</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">17</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.atom_charges">
<span class="sig-name descname"><span class="pre">atom_charges</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.atom_charges" title="Link to this definition"></a></dt>
<dd><p>np.asarray([mol.atom_charge(i) for i in range(mol.natm)])</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.atom_coord">
<span class="sig-name descname"><span class="pre">atom_coord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Bohr'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.atom_coord" title="Link to this definition"></a></dt>
<dd><p>Coordinates (ndarray) of the given atom id</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.atom_mass_list">
<span class="sig-name descname"><span class="pre">atom_mass_list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isotope_avg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.atom_mass_list" title="Link to this definition"></a></dt>
<dd><p>A list of mass for all atoms in the molecule</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>isotope_avg<span class="classifier">boolean</span></dt><dd><p>Whether to use the isotope average mass as the atomic mass</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.atom_nelec_core">
<span class="sig-name descname"><span class="pre">atom_nelec_core</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.atom_nelec_core" title="Link to this definition"></a></dt>
<dd><p>Number of core electrons for pseudo potential.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.atom_nshells">
<span class="sig-name descname"><span class="pre">atom_nshells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.atom_nshells" title="Link to this definition"></a></dt>
<dd><p>Number of basis/shells of the given atom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_nshells</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.atom_pure_symbol">
<span class="sig-name descname"><span class="pre">atom_pure_symbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">site</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.atom_pure_symbol" title="Link to this definition"></a></dt>
<dd><p>For the given atom id, return the standard symbol (striping special characters)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_pure_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.atom_shell_ids">
<span class="sig-name descname"><span class="pre">atom_shell_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.atom_shell_ids" title="Link to this definition"></a></dt>
<dd><p>A list of the shell-ids of the given atom</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_shell_ids</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[3, 4, 5, 6, 7]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.atom_symbol">
<span class="sig-name descname"><span class="pre">atom_symbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">site</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.atom_symbol" title="Link to this definition"></a></dt>
<dd><p>For the given atom id, return the input symbol (without striping special characters)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atm_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H^2 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">atom_symbol</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">H^2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_angular">
<span class="sig-name descname"><span class="pre">bas_angular</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_angular" title="Link to this definition"></a></dt>
<dd><p>The angular momentum associated with the given basis</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_angular</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_atom">
<span class="sig-name descname"><span class="pre">bas_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_atom" title="Link to this definition"></a></dt>
<dd><p>The atom (0-based id) that the given basis sits on</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_atom</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_coord">
<span class="sig-name descname"><span class="pre">bas_coord</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_coord" title="Link to this definition"></a></dt>
<dd><p>Coordinates (ndarray) associated with the given basis id</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_coord</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ 0.          0.          2.07869874]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_ctr_coeff">
<span class="sig-name descname"><span class="pre">bas_ctr_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_ctr_coeff" title="Link to this definition"></a></dt>
<dd><p>Contract coefficients (ndarray) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_ctr_coeff</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[[ 10.03400444]</span>
<span class="go"> [  4.1188704 ]</span>
<span class="go"> [  1.53971186]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_exp">
<span class="sig-name descname"><span class="pre">bas_exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_exp" title="Link to this definition"></a></dt>
<dd><p>exponents (ndarray) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_exp</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">[ 13.01     1.962    0.4446]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_exps">
<span class="sig-name descname"><span class="pre">bas_exps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_exps" title="Link to this definition"></a></dt>
<dd><p>exponents of all basis
return [mol.bas_exp(i) for i in range(self.nbas)]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_kappa">
<span class="sig-name descname"><span class="pre">bas_kappa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_kappa" title="Link to this definition"></a></dt>
<dd><p>Kappa (if l &lt; j, -l-1, else l) of the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_kappa</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_len_cart">
<span class="sig-name descname"><span class="pre">bas_len_cart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_len_cart" title="Link to this definition"></a></dt>
<dd><p>The number of Cartesian function associated with given basis</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_len_spinor">
<span class="sig-name descname"><span class="pre">bas_len_spinor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_len_spinor" title="Link to this definition"></a></dt>
<dd><p>The number of spinor associated with given basis
If kappa is 0, return 4l+2</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_nctr">
<span class="sig-name descname"><span class="pre">bas_nctr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_nctr" title="Link to this definition"></a></dt>
<dd><p>The number of contracted GTOs for the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_nctr</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_nprim">
<span class="sig-name descname"><span class="pre">bas_nprim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_nprim" title="Link to this definition"></a></dt>
<dd><p>The number of primitive GTOs for the given shell</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>bas_id</strong> – int
0-based</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;cc-pvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">bas_nprim</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">11</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.bas_rcut">
<span class="sig-name descname"><span class="pre">bas_rcut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.bas_rcut" title="Link to this definition"></a></dt>
<dd><p>Estimate the largest distance between the function and its image to
reach the precision in overlap</p>
<p>precision ~ int g(r-0) g(r-Rcut)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dump_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parse_arg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_dim_ft_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmorphic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_loose_rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_particle_mesh_ewald</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fractional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.build" title="Link to this definition"></a></dt>
<dd><p>Setup Mole molecule and Cell and initialize some control parameters.
Whenever you change the value of the attributes of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code>,
you need call this function to refresh the internal data of Cell.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>a<span class="classifier">(3,3) ndarray</span></dt><dd><p>The real-space cell lattice vectors. Each row represents
a lattice vector.</p>
</dd>
<dt>fractional<span class="classifier">bool</span></dt><dd><p>Whether the atom postions are specified in fractional coordinates.
The default value is False, which means the coordinates are
interpreted as Cartesian coordinate.</p>
</dd>
<dt>mesh<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>The number of <em>positive</em> G-vectors along each direction.</p>
</dd>
<dt>ke_cutoff<span class="classifier">float</span></dt><dd><p>If set, defines a spherical cutoff of planewaves, with .5 * G**2 &lt; ke_cutoff
The default value is estimated based on <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard2D.precision" title="vayesta.lattmod.latt.Hubbard2D.precision"><code class="xref py py-attr docutils literal notranslate"><span class="pre">precision</span></code></a></p>
</dd>
<dt>precision<span class="classifier">float</span></dt><dd><p>To control Ewald sums and lattice sums accuracy</p>
</dd>
<dt>nimgs<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>Number of repeated images in lattice summation to produce
periodicity. This value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>rcut<span class="classifier">float</span></dt><dd><p>Cutoff radius (unit Bohr) in lattice summation to produce
periodicity. The value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>h<span class="classifier">(3,3) ndarray</span></dt><dd><p>a.T. Deprecated</p>
</dd>
<dt>dimension<span class="classifier">int</span></dt><dd><p>Default is 3</p>
</dd>
<dt>low_dim_ft_type<span class="classifier">str</span></dt><dd><p>For semi-empirical periodic systems, whether to calculate
integrals at the non-PBC dimension using the sampled mesh grids in
infinity vacuum (inf_vacuum) or truncated Coulomb potential
(analytic_2d_1). Unless explicitly specified, analytic_2d_1 is
used for 2D system and inf_vacuum is assumed for 1D and 0D.</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry. Default is False.</p>
</dd>
<dt>symmorphic<span class="classifier">bool</span></dt><dd><p>Whether the lattice is symmorphic. If set to True, even if the
lattice is non-symmorphic, only symmorphic space group symmetry
will be considered. Default is False, meaning the space group is
determined by the lattice symmetry to be symmorphic or non-symmorphic.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.build_lattice_symmetry">
<span class="sig-name descname"><span class="pre">build_lattice_symmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">check_mesh_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.build_lattice_symmetry" title="Link to this definition"></a></dt>
<dd><p>Build cell.lattice_symmetry object.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>check_mesh_symmetry<span class="classifier">bool</span></dt><dd><p>For nonsymmorphic symmetry groups, <cite>cell.mesh</cite> may have
lower symmetry than the lattice. In this case, if
<cite>check_mesh_symmetry</cite> is <cite>True</cite>, the lower symmetry group will
be used. Otherwise, if <cite>check_mesh_symmetry</cite> is <cite>False</cite>,
the mesh grid will be modified to satisfy the higher symmetry.
Default value is <cite>True</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function modifies the attributes of <cite>cell</cite>.</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.cart">
<span class="sig-name descname"><span class="pre">cart</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.cart" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.cart2sph_coeff">
<span class="sig-name descname"><span class="pre">cart2sph_coeff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sp'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.cart2sph_coeff" title="Link to this definition"></a></dt>
<dd><p>Transformation matrix that transforms Cartesian GTOs to spherical
GTOs for all basis functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>normalized<span class="classifier">string or boolean</span></dt><dd><p>How the Cartesian GTOs are normalized.  Except s and p functions,
Cartesian GTOs do not have the universal normalization coefficients
for the different components of the same shell.  The value of this
argument can be one of ‘sp’, ‘all’, None.  ‘sp’ means the Cartesian s
and p basis are normalized.  ‘all’ means all Cartesian functions are
normalized.  None means none of the Cartesian functions are normalized.
The default value ‘sp’ is the convention used by libcint library.</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">cart2sph_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_cart&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">4.58676826646e-15</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.cart_labels">
<span class="sig-name descname"><span class="pre">cart_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.cart_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of Cartesian GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-xyz-notation)]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.charge">
<span class="sig-name descname"><span class="pre">charge</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.charge" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.check_sanity">
<span class="sig-name descname"><span class="pre">check_sanity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.check_sanity" title="Link to this definition"></a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.condense_to_shell">
<span class="sig-name descname"><span class="pre">condense_to_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compressor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'max'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.condense_to_shell" title="Link to this definition"></a></dt>
<dd><p>The given matrix is first partitioned to blocks, based on AO shell as
delimiter. Then call compressor function to abstract each block.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>compressor</strong> – string or function
if compressor is a string, its value can be  sum, max, min, abssum,
absmax, absmin, norm</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.copy" title="Link to this definition"></a></dt>
<dd><p>Deepcopy of the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
<p>Some attributes are shared between the original and copied objects.
Deepcopy is utilized here to ensure that operations on the copied object do
not affect the original object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.cutoff_to_mesh">
<span class="sig-name descname"><span class="pre">cutoff_to_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.cutoff_to_mesh" title="Link to this definition"></a></dt>
<dd><p>Convert KE cutoff to FFT-mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ke_cutoff</strong> – float
KE energy cutoff in a.u.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(3,) array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.decontract_basis">
<span class="sig-name descname"><span class="pre">decontract_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.decontract_basis" title="Link to this definition"></a></dt>
<dd><p>Decontract the basis of a Mole or a Cell.  Returns a Mole (Cell) object
with the uncontracted basis environment and a list of coefficients that
transform the uncontracted basis to the original basis. Each element in
the coefficients list corresponds to one shell of the original Mole (Cell).</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>atoms: list or str</dt><dd><p>Atoms on which the basis to be decontracted. By default, all basis
are decontracted</p>
</dd>
<dt>to_cart: bool</dt><dd><p>Decontract basis and transfer to Cartesian basis</p>
</dd>
<dt>aggregate: bool</dt><dd><p>Whether to aggregate the transformation coefficients into a giant
transformation matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Ne&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmol</span><span class="p">,</span> <span class="n">ctr_coeff</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">decontract_basis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">ctr_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.drop_exponent">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">drop_exponent</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.drop_exponent" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.dump_input">
<span class="sig-name descname"><span class="pre">dump_input</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.dump_input" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.dumps">
<span class="sig-name descname"><span class="pre">dumps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.dumps" title="Link to this definition"></a></dt>
<dd><p>Serialize Cell object to a JSON formatted str.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.elements">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">elements</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.elements" title="Link to this definition"></a></dt>
<dd><p>A list of elements in the molecule</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.energy_nuc">
<span class="sig-name descname"><span class="pre">energy_nuc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.energy_nuc" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.enuc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enuc</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.enuc" title="Link to this definition"></a></dt>
<dd><p>nuclear repulsion energy</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.etbs">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">etbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">etbs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.etbs" title="Link to this definition"></a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard2D.expand_etb" title="vayesta.lattmod.latt.Hubbard2D.expand_etb"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand_etb()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[</strong> (<em>etbs =</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.eval_ao">
<span class="sig-name descname"><span class="pre">eval_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.eval_ao" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.eval_gto">
<span class="sig-name descname"><span class="pre">eval_gto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.eval_gto" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.ew_cut">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ew_cut</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.ew_cut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.ew_eta">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ew_eta</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.ew_eta" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.ewald">
<span class="sig-name descname"><span class="pre">ewald</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.ewald" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.exp_to_discard">
<span class="sig-name descname"><span class="pre">exp_to_discard</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.exp_to_discard" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.expand_etb">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">expand_etb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.expand_etb" title="Link to this definition"></a></dt>
<dd><p>Generate the exponents of even tempered basis for <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code>.
.. math:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">e</span> <span class="o">=</span> <span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="o">-</span>\<span class="n">alpha</span> <span class="o">*</span> \<span class="n">beta</span><span class="o">^</span><span class="p">{</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">}}</span> <span class="k">for</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">..</span> <span class="n">n</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l</strong> – int
Angular momentum</p></li>
<li><p><strong>n</strong> – int
Number of GTOs</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etb</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">[[1, [6.0, 1]], [1, [3.0, 1]], [1, [1.5, 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.expand_etbs">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">expand_etbs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">etbs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.expand_etbs" title="Link to this definition"></a></dt>
<dd><p>Generate even tempered basis.  See also <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard2D.expand_etb" title="vayesta.lattmod.latt.Hubbard2D.expand_etb"><code class="xref py py-func docutils literal notranslate"><span class="pre">expand_etb()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>[</strong> (<em>etbs =</em>)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">expand_etbs</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)])</span>
<span class="go">[[0, [6.0, 1]], [0, [3.0, 1]], [1, [1., 1]], [1, [2., 1]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.format_atom">
<span class="sig-name descname"><span class="pre">format_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'angstrom'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.format_atom" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.atom</span></code> to the internal data format.
Including, changing the nuclear charge to atom symbol, converting the
coordinates to AU, rotate and shift the molecule.
If the <code class="xref py py-attr docutils literal notranslate"><span class="pre">atom</span></code> is a string, it takes “;” and “n”
for the mark to separate atoms;  “,” and arbitrary length of blank space
to separate the individual terms for an atom.  Blank line will be ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atoms</strong> – list or str
the same to <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.atom</span></code></p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>origin<span class="classifier">ndarray</span></dt><dd><p>new axis origin.</p>
</dd>
<dt>axes<span class="classifier">ndarray</span></dt><dd><p>(new_x, new_y, new_z), new coordinates</p>
</dd>
<dt>unit<span class="classifier">str or number</span></dt><dd><p>If unit is one of strings (B, b, Bohr, bohr, AU, au), the coordinates
of the input atoms are the atomic unit;  If unit is one of strings
(A, a, Angstrom, angstrom, Ang, ang), the coordinates are in the
unit of angstrom;  If a number is given, the number are considered
as the Bohr value (in angstrom), which should be around 0.53.
Set unit=1 if wishing to preserve the unit of the coordinates.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl>
<dt>“atoms” in the internal format. The internal format is</dt><dd><div class="line-block">
<div class="line">atom = [[atom1, (x, y, z)],</div>
<div class="line-block">
<div class="line">[atom2, (x, y, z)],</div>
<div class="line">…</div>
<div class="line">[atomN, (x, y, z)]]</div>
</div>
</div>
</dd>
</dl>
</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">(</span><span class="s1">&#39;9,0,0,0; h@1 0 0 1&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H@1&#39;, [-1.0, -1.0, 0.0]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_atom</span><span class="p">([</span><span class="s1">&#39;9,0,0,0&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))],</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[&#39;F&#39;, [-1.0, -1.0, -1.0]], [&#39;H&#39;, [-1, -1, 0]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.format_basis">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_tab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.format_basis" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code> to the internal data format.</p>
<dl>
<dt><a href="#id7"><span class="problematic" id="id8">``</span></a>{ atom: [(l, ((-exp, c_1, c_2, ..),</dt><dd><blockquote>
<div><p>(-exp, c_1, c_2, ..))),</p>
</div></blockquote>
<dl class="simple">
<dt>(l, ((-exp, c_1, c_2, ..),</dt><dd><p>(-exp, c_1, c_2, ..)))], … }``</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>basis_tab</strong> – dict
Similar to <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code>, it <strong>cannot</strong> be a str</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">basis</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">,</span> <span class="s1">&#39;H^2&#39;</span><span class="p">:</span> <span class="s1">&#39;3-21g&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    [3.4252509099999999, 0.15432897000000001],</span>
<span class="go">    [0.62391373000000006, 0.53532813999999995],</span>
<span class="go">    [0.16885539999999999, 0.44463454000000002]]],</span>
<span class="go"> &#39;H^2&#39;: [[0,</span>
<span class="go">    [5.4471780000000001, 0.15628500000000001],</span>
<span class="go">    [0.82454700000000003, 0.90469100000000002]],</span>
<span class="go">    [0, [0.18319199999999999, 1.0]]]}</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">format_basis</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;gth-szv&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[0,</span>
<span class="go">    (8.3744350009, -0.0283380461),</span>
<span class="go">    (1.8058681460, -0.1333810052),</span>
<span class="go">    (0.4852528328, -0.3995676063),</span>
<span class="go">    (0.1658236932, -0.5531027541)]]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.format_ecp">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_ecp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ecp_tab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.format_ecp" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">ecp</span></code> (dict) to the internal data format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span><span class="n">nelec</span><span class="p">,</span>  <span class="c1"># core electrons</span>
</pre></div>
</div>
<blockquote>
<div><blockquote>
<div><dl>
<dt>((l,  # l=-1 for UL, l&gt;=0 for Ul to indicate <a href="#id28"><span class="problematic" id="id29">|l&gt;&lt;l|</span></a></dt><dd><dl>
<dt>(((exp_1, c_1),  # for r^0</dt><dd><blockquote>
<div><p>(exp_2, c_2),
…),</p>
</div></blockquote>
<dl class="simple">
<dt>((exp_1, c_1),  # for r^1</dt><dd><p>(exp_2, c_2),
…),</p>
</dd>
<dt>((exp_1, c_1),  # for r^2</dt><dd><p>…))))),</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>…}</p>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.format_pseudo">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">format_pseudo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pseudo_tab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.format_pseudo" title="Link to this definition"></a></dt>
<dd><p>Convert the input <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code> (dict) to the internal data format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span> <span class="n">atom</span><span class="p">:</span> <span class="p">(</span> <span class="p">(</span><span class="n">nelec_s</span><span class="p">,</span> <span class="n">nele_p</span><span class="p">,</span> <span class="n">nelec_d</span><span class="p">,</span> <span class="o">...</span><span class="p">),</span>
         <span class="n">rloc</span><span class="p">,</span> <span class="n">nexp</span><span class="p">,</span> <span class="p">(</span><span class="n">cexp_1</span><span class="p">,</span> <span class="n">cexp_2</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">cexp_nexp</span><span class="p">),</span>
         <span class="n">nproj_types</span><span class="p">,</span>
         <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">nproj1</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
                        <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
                        <span class="o">...</span>
                        <span class="p">(</span><span class="n">hproj1</span><span class="p">[</span><span class="n">nproj1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj1</span><span class="p">[</span><span class="n">nproj1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span>        <span class="p">)</span> <span class="p">)),</span>
         <span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">nproj2</span><span class="p">,</span> <span class="p">(</span> <span class="p">(</span><span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">hproj2</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">nproj1</span><span class="p">]),</span>
         <span class="o">...</span> <span class="p">)</span> <span class="p">)</span>
         <span class="p">)</span>
 <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>pseudo_tab</strong> – dict
Similar to <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code> (a dict), it <strong>cannot</strong> be a str</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Formatted <code class="xref py py-attr docutils literal notranslate"><span class="pre">pseudo</span></code></p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pbc</span><span class="o">.</span><span class="n">format_pseudo</span><span class="p">({</span><span class="s1">&#39;H&#39;</span><span class="p">:</span><span class="s1">&#39;gth-blyp&#39;</span><span class="p">,</span> <span class="s1">&#39;He&#39;</span><span class="p">:</span> <span class="s1">&#39;gth-pade&#39;</span><span class="p">})</span>
<span class="go">{&#39;H&#39;: [[1],</span>
<span class="go">    0.2, 2, [-4.19596147, 0.73049821], 0],</span>
<span class="go"> &#39;He&#39;: [[2],</span>
<span class="go">    0.2, 2, [-9.1120234, 1.69836797], 0]}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.fractional">
<span class="sig-name descname"><span class="pre">fractional</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.fractional" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.from_ase">
<span class="sig-name descname"><span class="pre">from_ase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ase_atom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.from_ase" title="Link to this definition"></a></dt>
<dd><p>Update cell based on given ase atom object</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">ase.lattice</span><span class="w"> </span><span class="kn">import</span> <span class="n">bulk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">from_ase</span><span class="p">(</span><span class="n">bulk</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;diamond&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">LATTICE_CONST</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.fromfile">
<span class="sig-name descname"><span class="pre">fromfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.fromfile" title="Link to this definition"></a></dt>
<dd><p>Update the Cell object based on the input geometry file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.fromstring">
<span class="sig-name descname"><span class="pre">fromstring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'poscar'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.fromstring" title="Link to this definition"></a></dt>
<dd><p>Update the Cell object based on the input geometry string</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.gen_uniform_grids">
<span class="sig-name descname"><span class="pre">gen_uniform_grids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.gen_uniform_grids" title="Link to this definition"></a></dt>
<dd><p>Generate a uniform real-space grid consistent w/ samp thm; see MH (3.19).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngx*ngy*ngz, 3) ndarray</dt><dd><p>The real-space grid point coordinates.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>coords</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_Gv">
<span class="sig-name descname"><span class="pre">get_Gv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_Gv" title="Link to this definition"></a></dt>
<dd><p>Calculate three-dimensional G-vectors for the cell; see MH (3.8).</p>
<p>Indices along each direction go as [0…N-1, -N…-1] to follow FFT convention.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngrids, 3) ndarray of floats</dt><dd><p>The array of G-vectors.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Gv</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_Gv_weights">
<span class="sig-name descname"><span class="pre">get_Gv_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_Gv_weights" title="Link to this definition"></a></dt>
<dd><p>Calculate G-vectors and weights.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>(ngris, 3) ndarray of floats</dt><dd><p>The array of G-vectors.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Gv</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_SI">
<span class="sig-name descname"><span class="pre">get_SI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Gv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmlst</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_SI" title="Link to this definition"></a></dt>
<dd><p>Calculate the structure factor (0D, 1D, 2D, 3D) for all atoms; see MH (3.34).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p></li>
<li><p><strong>Gv</strong> – (N,3) array
G vectors</p></li>
<li><p><strong>atmlst</strong> – list of ints, optional
Indices of atoms for which the structure factors are computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(natm, ngrids) ndarray, dtype=np.complex128</dt><dd><p>The structure factor for each atom at each G-vector.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>SI</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_abs_kpts">
<span class="sig-name descname"><span class="pre">get_abs_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scaled_kpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_abs_kpts" title="Link to this definition"></a></dt>
<dd><p>Get absolute k-points (in 1/Bohr), given “scaled” k-points in
fractions of lattice vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>scaled_kpts</strong> – (nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>abs_kpts</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_ao_indices">
<span class="sig-name descname"><span class="pre">get_ao_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_ao_indices" title="Link to this definition"></a></dt>
<dd><p>Generate (dis-continued) AO indices for basis specified in bas_list</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_bounding_sphere">
<span class="sig-name descname"><span class="pre">get_bounding_sphere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rcut</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_bounding_sphere" title="Link to this definition"></a></dt>
<dd><p>Finds all the lattice points within a sphere of radius rcut.</p>
<p>Defines a parallelepiped given by -N_x &lt;= n_x &lt;= N_x, with x in [1,3]
See Martin p. 85</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>rcut</strong> – number
real space cut-off for interaction</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ndarray of 3 ints defining N_x</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>cut</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_enuc">
<span class="sig-name descname"><span class="pre">get_enuc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ew_eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ew_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_enuc" title="Link to this definition"></a></dt>
<dd><p>Perform real (R) and reciprocal (G) space Ewald sum for the energy.</p>
<p>Formulation of Martin, App. F2.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald energy consisting of overlap, self, and G-space sum.</p>
</dd>
</dl>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>pyscf.pbc.gto.get_ewald_params</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_ewald_params">
<span class="sig-name descname"><span class="pre">get_ewald_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_ewald_params" title="Link to this definition"></a></dt>
<dd><p>Choose a reasonable value of Ewald ‘eta’ and ‘cut’ parameters.
eta^2 is the exponent coefficient of the model Gaussian charge for nucleus
at R:  frac{eta^3}{pi^1.5} e^{-eta^2 (r-R)^2}</p>
<p>Choice is based on largest G vector and desired relative precision.</p>
<p>The relative error in the G-space sum is given by</p>
<blockquote>
<div><p>precision ~ 4pi Gmax^2 e^{(-Gmax^2)/(4 eta^2)}</p>
</div></blockquote>
<p>which determines eta. Then, real-space cutoff is determined by (exp.
factors only)</p>
<blockquote>
<div><p>precision ~ erfc(eta*rcut) / rcut ~ e^{(-eta**2 rcut*2)}</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><dl class="simple">
<dt>float</dt><dd><p>The Ewald ‘eta’ and ‘cut’ parameters.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>ew_eta, ew_cut</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_kpts">
<span class="sig-name descname"><span class="pre">get_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_gamma_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_reversal_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_kpts" title="Link to this definition"></a></dt>
<dd><p>Given number of kpoints along x,y,z , generate kpoints</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nks</strong> – (3,) ndarray</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>wrap_around<span class="classifier">bool</span></dt><dd><p>To ensure all kpts are in first Brillouin zone.</p>
</dd>
<dt>with_gamma_point<span class="classifier">bool</span></dt><dd><p>Whether to shift Monkhorst-pack grid to include gamma-point.</p>
</dd>
<dt>scaled_center<span class="classifier">(3,) array</span></dt><dd><p>Shift all points in the Monkhorst-pack grid to be centered on
scaled_center, given as the zeroth index of the returned kpts.
Scaled meaning that the k-points are scaled to a grid from
[-1,1] x [-1,1] x [-1,1]</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry</p>
</dd>
<dt>time_reversal_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider time reversal symmetry</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>kpts in absolute value (unit 1/Bohr).  Gamma point is placed at the
first place in the k-points list;
instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> if k-point symmetry is considered</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_lattice_Ls">
<span class="sig-name descname"><span class="pre">get_lattice_Ls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discard</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_lattice_Ls" title="Link to this definition"></a></dt>
<dd><p>Get the (Cartesian, unitful) lattice translation vectors for nearby images.
The translation vectors can be used for the lattice summation.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>discard:</dt><dd><p>Drop less important Ls based on AO values on grid</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_nimgs">
<span class="sig-name descname"><span class="pre">get_nimgs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_nimgs" title="Link to this definition"></a></dt>
<dd><p>Choose number of basis function images in lattice sums
to include for given precision in overlap, using</p>
<p>precision ~ int r^l e^{-alpha r^2} (r-rcut)^l e^{-alpha (r-rcut)^2}
~ (rcut^2/(2alpha))^l e^{alpha/2 rcut^2}</p>
<p>where alpha is the smallest exponent in the basis. Note
that assumes an isolated exponent in the middle of the box, so
it adds one additional lattice vector to be safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_overlap_cond">
<span class="sig-name descname"><span class="pre">get_overlap_cond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_overlap_cond" title="Link to this definition"></a></dt>
<dd><p>Overlap magnitudes measured by -log(overlap) between two shells</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>2D mask array of shape (nbas,nbas)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_scaled_atom_coords">
<span class="sig-name descname"><span class="pre">get_scaled_atom_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_scaled_atom_coords" title="Link to this definition"></a></dt>
<dd><p>Get scaled atomic coordinates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_scaled_kpts">
<span class="sig-name descname"><span class="pre">get_scaled_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">abs_kpts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts_in_ibz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_scaled_kpts" title="Link to this definition"></a></dt>
<dd><p>Get scaled k-points, given absolute k-points in 1/Bohr.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>abs_kpts</strong> – (nkpts, 3) ndarray of floats or <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> object</p></li>
<li><p><strong>kpts_in_ibz</strong> – bool
If True, return k-points in IBZ; otherwise, return k-points in BZ.
Default value is True. This has effects only if abs_kpts is a
<code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> object</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(nkpts, 3) ndarray of floats</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>scaled_kpts</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.get_uniform_grids">
<span class="sig-name descname"><span class="pre">get_uniform_grids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.get_uniform_grids" title="Link to this definition"></a></dt>
<dd><p>Generate a uniform real-space grid consistent w/ samp thm; see MH (3.19).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cell</strong> – instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code></p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(ngx*ngy*ngz, 3) ndarray</dt><dd><p>The real-space grid point coordinates.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>coords</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.gs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gs</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.gs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.gto_norm">
<span class="sig-name descname"><span class="pre">gto_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expnt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.gto_norm" title="Link to this definition"></a></dt>
<dd><p>Normalized factor for GTO radial part   <span class="math notranslate nohighlight">\(g=r^l e^{-\alpha r^2}\)</span></p>
<div class="math notranslate nohighlight">
\[\frac{1}{\sqrt{\int g^2 r^2 dr}}
= \sqrt{\frac{2^{2l+3} (l+1)! (2a)^{l+1.5}}{(2l+2)!\sqrt{\pi}}}\]</div>
<p>Ref: H. B. Schlegel and M. J. Frisch, Int. J. Quant.  Chem., 54(1995), 83-87.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>l</strong> (<em>int</em>) – angular momentum</p></li>
<li><p><strong>expnt</strong> – exponent <span class="math notranslate nohighlight">\(\alpha\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>normalization factor</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gto_norm</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">2.5264751109842591</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.h">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">h</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.h" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.has_ecp">
<span class="sig-name descname"><span class="pre">has_ecp</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.has_ecp" title="Link to this definition"></a></dt>
<dd><p>Whether pseudo potential is used in the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.has_ecp_soc">
<span class="sig-name descname"><span class="pre">has_ecp_soc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.has_ecp_soc" title="Link to this definition"></a></dt>
<dd><p>Whether spin-orbit coupling is enabled in ECP.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.incore_anyway">
<span class="sig-name descname"><span class="pre">incore_anyway</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.incore_anyway" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.intor">
<span class="sig-name descname"><span class="pre">intor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aosym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'s1'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.intor" title="Link to this definition"></a></dt>
<dd><p>Integral generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1e or 2e AO integrals.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Symmetry of the integrals</p>
<div class="line-block">
<div class="line">0 : no symmetry assumed (default)</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>shls_slice<span class="classifier">4-element, 6-element or 8-element tuple</span></dt><dd><p>Label the start-stop shells for each index in the integral.
For example, the 8-element tuple for the 2-electron integral
tensor (ij|kl) = intor(‘int2e’) are specified as
(ish_start, ish_end, jsh_start, jsh_end, ksh_start, ksh_end, lsh_start, lsh_end)</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ipnuc_sph&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span> <span class="c1"># &lt;nabla i | V_nuc | j&gt;</span>
<span class="go">[[[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.          0.        ]</span>
<span class="go">  [ 0.          0.        ]]</span>
<span class="go"> [[ 0.10289944  0.48176097]</span>
<span class="go">  [-0.48176097 -0.10289944]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.intor_asymmetric">
<span class="sig-name descname"><span class="pre">intor_asymmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.intor_asymmetric" title="Link to this definition"></a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be anti-hermitian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp has 3 components.</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_asymmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j  0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j  0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.intor_by_shell">
<span class="sig-name descname"><span class="pre">intor_by_shell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.intor_by_shell" title="Link to this definition"></a></dt>
<dd><p>For given 2, 3 or 4 shells, interface for libcint to get 1e, 2e,
2-center-2e or 3-center-2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>intor_name</strong> – str
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the supported intor_name</p></li>
<li><p><strong>shls</strong> – list of int
The AO shell-ids of the integrals</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp has 3 components.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 2-dim to 5-dim, depending on the integral type (1e,
2e, 3c-2e, 2c2e) and the value of comp</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The gradients of the spherical 2e integrals</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">getints_by_shell</span><span class="p">(</span><span class="s1">&#39;int2e_ip1_sph&#39;</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">_atm</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_bas</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">_env</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[[[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.        ]]]]</span>
<span class="go">  [[[[-0.08760462]]]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.intor_symmetric">
<span class="sig-name descname"><span class="pre">intor_symmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.intor_symmetric" title="Link to this definition"></a></dt>
<dd><p>One-electron integral generator. The integrals are assumed to be hermitian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>intor</strong> – str
Name of the 1-electron integral.  Ref to <code class="xref py py-func docutils literal notranslate"><span class="pre">getints()</span></code> for the
complete list of available 1-electron integral names</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>comp<span class="classifier">int</span></dt><dd><p>Components of the integrals, e.g. int1e_ipovlp_sph has 3 components.</p>
</dd>
<dt>grids<span class="classifier">ndarray</span></dt><dd><p>Coordinates of grids for the int1e_grids integrals</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ndarray of 1-electron integrals, can be either 2-dim or 3-dim, depending on comp</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">intor_symmetric</span><span class="p">(</span><span class="s1">&#39;int1e_nuc_spinor&#39;</span><span class="p">)</span>
<span class="go">[[-1.69771092+0.j  0.00000000+0.j -0.67146312+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -1.69771092+0.j  0.00000000+0.j -0.67146312+0.j]</span>
<span class="go"> [-0.67146312+0.j  0.00000000+0.j -1.69771092+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.67146312+0.j  0.00000000+0.j -1.69771092+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.kernel">
<span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dump_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parse_arg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ke_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nimgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_dim_ft_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmorphic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_loose_rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_particle_mesh_ewald</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fractional</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.kernel" title="Link to this definition"></a></dt>
<dd><p>Setup Mole molecule and Cell and initialize some control parameters.
Whenever you change the value of the attributes of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code>,
you need call this function to refresh the internal data of Cell.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>a<span class="classifier">(3,3) ndarray</span></dt><dd><p>The real-space cell lattice vectors. Each row represents
a lattice vector.</p>
</dd>
<dt>fractional<span class="classifier">bool</span></dt><dd><p>Whether the atom postions are specified in fractional coordinates.
The default value is False, which means the coordinates are
interpreted as Cartesian coordinate.</p>
</dd>
<dt>mesh<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>The number of <em>positive</em> G-vectors along each direction.</p>
</dd>
<dt>ke_cutoff<span class="classifier">float</span></dt><dd><p>If set, defines a spherical cutoff of planewaves, with .5 * G**2 &lt; ke_cutoff
The default value is estimated based on <a class="reference internal" href="#vayesta.lattmod.latt.Hubbard2D.precision" title="vayesta.lattmod.latt.Hubbard2D.precision"><code class="xref py py-attr docutils literal notranslate"><span class="pre">precision</span></code></a></p>
</dd>
<dt>precision<span class="classifier">float</span></dt><dd><p>To control Ewald sums and lattice sums accuracy</p>
</dd>
<dt>nimgs<span class="classifier">(3,) ndarray of ints</span></dt><dd><p>Number of repeated images in lattice summation to produce
periodicity. This value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>rcut<span class="classifier">float</span></dt><dd><p>Cutoff radius (unit Bohr) in lattice summation to produce
periodicity. The value can be estimated based on the required
precision.  It’s recommended NOT making changes to this value.</p>
</dd>
<dt>h<span class="classifier">(3,3) ndarray</span></dt><dd><p>a.T. Deprecated</p>
</dd>
<dt>dimension<span class="classifier">int</span></dt><dd><p>Default is 3</p>
</dd>
<dt>low_dim_ft_type<span class="classifier">str</span></dt><dd><p>For semi-empirical periodic systems, whether to calculate
integrals at the non-PBC dimension using the sampled mesh grids in
infinity vacuum (inf_vacuum) or truncated Coulomb potential
(analytic_2d_1). Unless explicitly specified, analytic_2d_1 is
used for 2D system and inf_vacuum is assumed for 1D and 0D.</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry. Default is False.</p>
</dd>
<dt>symmorphic<span class="classifier">bool</span></dt><dd><p>Whether the lattice is symmorphic. If set to True, even if the
lattice is non-symmorphic, only symmorphic space group symmetry
will be considered. Default is False, meaning the space group is
determined by the lattice symmetry to be symmorphic or non-symmorphic.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.lattice_symmetry">
<span class="sig-name descname"><span class="pre">lattice_symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.lattice_symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.loads">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">loads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molstr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.loads" title="Link to this definition"></a></dt>
<dd><p>Deserialize a str containing a JSON document to a Cell object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.loads_">
<span class="sig-name descname"><span class="pre">loads_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">molstr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.loads_" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.low_dim_ft_type">
<span class="sig-name descname"><span class="pre">low_dim_ft_type</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.low_dim_ft_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.make_atm_env">
<span class="sig-name descname"><span class="pre">make_atm_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucmod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucprop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.make_atm_env" title="Link to this definition"></a></dt>
<dd><p>Convert the internal format <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._atom</span></code> to the format required
by <code class="docutils literal notranslate"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.make_bas_env">
<span class="sig-name descname"><span class="pre">make_bas_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis_add</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ptr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.make_bas_env" title="Link to this definition"></a></dt>
<dd><p>Convert <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole.basis</span></code> to the argument <code class="docutils literal notranslate"><span class="pre">bas</span></code> for <code class="docutils literal notranslate"><span class="pre">libcint</span></code> integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.make_ecp_env">
<span class="sig-name descname"><span class="pre">make_ecp_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_atm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_ecp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.make_ecp_env" title="Link to this definition"></a></dt>
<dd><p>Generate the input arguments _ecpbas for ECP integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.make_env">
<span class="sig-name descname"><span class="pre">make_env</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_env</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucmod</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nucprop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.make_env" title="Link to this definition"></a></dt>
<dd><p>Generate the input arguments for <code class="docutils literal notranslate"><span class="pre">libcint</span></code> library based on internal
format <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._atom</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">Mole._basis</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.make_kpts">
<span class="sig-name descname"><span class="pre">make_kpts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wrap_around</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_gamma_point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaled_center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_group_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_reversal_symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.make_kpts" title="Link to this definition"></a></dt>
<dd><p>Given number of kpoints along x,y,z , generate kpoints</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>nks</strong> – (3,) ndarray</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>wrap_around<span class="classifier">bool</span></dt><dd><p>To ensure all kpts are in first Brillouin zone.</p>
</dd>
<dt>with_gamma_point<span class="classifier">bool</span></dt><dd><p>Whether to shift Monkhorst-pack grid to include gamma-point.</p>
</dd>
<dt>scaled_center<span class="classifier">(3,) array</span></dt><dd><p>Shift all points in the Monkhorst-pack grid to be centered on
scaled_center, given as the zeroth index of the returned kpts.
Scaled meaning that the k-points are scaled to a grid from
[-1,1] x [-1,1] x [-1,1]</p>
</dd>
<dt>space_group_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider space group symmetry</p>
</dd>
<dt>time_reversal_symmetry<span class="classifier">bool</span></dt><dd><p>Whether to consider time reversal symmetry</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>kpts in absolute value (unit 1/Bohr).  Gamma point is placed at the
first place in the k-points list;
instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">KPoints</span></code> if k-point symmetry is considered</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.max_memory">
<span class="sig-name descname"><span class="pre">max_memory</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4000</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.max_memory" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.mesh">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mesh</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.mesh" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.ms">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ms</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.ms" title="Link to this definition"></a></dt>
<dd><p>Spin quantum number. multiplicity = ms*2+1</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.multiplicity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">multiplicity</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.multiplicity" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.nao">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nao</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.nao" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.nao_2c">
<span class="sig-name descname"><span class="pre">nao_2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.nao_2c" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted spinor GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.nao_2c_range">
<span class="sig-name descname"><span class="pre">nao_2c_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bas_id1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.nao_2c_range" title="Link to this definition"></a></dt>
<dd><p>Lower and upper boundary of contracted spinor basis functions associated
with the given shell range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p></li>
<li><p><strong>bas_id0</strong> – int
start shell id, 0-based</p></li>
<li><p><strong>bas_id1</strong> – int
stop shell id, 0-based</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple of start basis function id and the stop function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_2c_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(4, 12)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.nao_cart">
<span class="sig-name descname"><span class="pre">nao_cart</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.nao_cart" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted cartesian GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.nao_nr">
<span class="sig-name descname"><span class="pre">nao_nr</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.nao_nr" title="Link to this definition"></a></dt>
<dd><p>Total number of contracted GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.nao_nr_range">
<span class="sig-name descname"><span class="pre">nao_nr_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bas_id0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bas_id1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.nao_nr_range" title="Link to this definition"></a></dt>
<dd><p>Lower and upper boundary of contracted spherical basis functions associated
with the given shell range</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p></li>
<li><p><strong>bas_id0</strong> – int
start shell id</p></li>
<li><p><strong>bas_id1</strong> – int
stop shell id</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple of start basis function id and the stop function id</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; C 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">nao_nr_range</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">(2, 6)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.natm">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">natm</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.natm" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.nbas">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nbas</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.nbas" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.nelec">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.nelec" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.nelectron">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelectron</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.nelectron" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.nimgs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nimgs</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.nimgs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.npgto_nr">
<span class="sig-name descname"><span class="pre">npgto_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.npgto_nr" title="Link to this definition"></a></dt>
<dd><p>Total number of primitive spherical GTOs for the given <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code> object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.offset_2c_by_atom">
<span class="sig-name descname"><span class="pre">offset_2c_by_atom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.offset_2c_by_atom" title="Link to this definition"></a></dt>
<dd><p>2-component AO offset for each atom.  Return a list, each item
of the list gives (start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.offset_ao_by_atom">
<span class="sig-name descname"><span class="pre">offset_ao_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.offset_ao_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.offset_nr_by_atom">
<span class="sig-name descname"><span class="pre">offset_nr_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.offset_nr_by_atom" title="Link to this definition"></a></dt>
<dd><p>AO offsets for each atom.  Return a list, each item of the list gives
(start-shell-id, stop-shell-id, start-AO-id, stop-AO-id)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.omega">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">omega</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.omega" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.output">
<span class="sig-name descname"><span class="pre">output</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.output" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.pack">
<span class="sig-name descname"><span class="pre">pack</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.pack" title="Link to this definition"></a></dt>
<dd><p>Pack the input args of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> to a dict, which can be serialized
with <code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.pbc_eval_ao">
<span class="sig-name descname"><span class="pre">pbc_eval_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.pbc_eval_ao" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.pbc_eval_gto">
<span class="sig-name descname"><span class="pre">pbc_eval_gto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eval_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non0tab</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ao_loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ls</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.pbc_eval_gto" title="Link to this definition"></a></dt>
<dd><p>Evaluate PBC-AO function value on the given grids,</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>eval_name</strong> – <p>str:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========================</span>  <span class="o">=======================</span>
<span class="n">Function</span>                    <span class="n">Expression</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
<span class="s2">&quot;GTOval_sph&quot;</span>                \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_sph&quot;</span>             <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_cart&quot;</span>               \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="s2">&quot;GTOval_ip_cart&quot;</span>            <span class="n">nabla</span> \<span class="n">sum_T</span> <span class="n">exp</span><span class="p">(</span><span class="n">ik</span><span class="o">*</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span><span class="n">AO</span><span class="o">&gt;</span>
<span class="o">==========================</span>  <span class="o">=======================</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atm</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>bas</strong> – int32 ndarray
libcint integral function argument</p></li>
<li><p><strong>env</strong> – float64 ndarray
libcint integral function argument</p></li>
<li><p><strong>coords</strong> – 2D array, shape (N,3)
The coordinates of the grids.</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>shls_slice<span class="classifier">2-element list</span></dt><dd><p>(shl_start, shl_end).
If given, only part of AOs (shl_start &lt;= shell_id &lt; shl_end) are
evaluated.  By default, all shells defined in cell will be evaluated.</p>
</dd>
<dt>non0tab<span class="classifier">2D bool array</span></dt><dd><p>mask array to indicate whether the AO values are zero.  The mask
array can be obtained by calling <code class="xref py py-func docutils literal notranslate"><span class="pre">dft.gen_grid.make_mask()</span></code></p>
</dd>
<dt>cutoff<span class="classifier">float</span></dt><dd><p>AO values smaller than cutoff will be set to zero. The default
cutoff threshold is ~1e-22 (defined in gto/grid_ao_drv.h)</p>
</dd>
<dt>out<span class="classifier">ndarray</span></dt><dd><p>If provided, results are written into this array.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of 2D (or 3D) arrays to hold the AO values on grids.  Each
element of the list corresponds to a k-point and it has the shape
(N,nao) Or shape (*,N,nao).</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell</span> <span class="o">=</span> <span class="n">pbc</span><span class="o">.</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="s1">&#39;He 1 1 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;6-31g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">get_uniform_grids</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kpts</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">make_kpts</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1000, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span> <span class="o">=</span> <span class="n">cell</span><span class="o">.</span><span class="n">pbc_eval_gto</span><span class="p">(</span><span class="s2">&quot;GTOval_ig_sph&quot;</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">kpts</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ao_value</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">ao_value</span><span class="p">)</span>
<span class="go">27</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ao_value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 1000, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.pbc_intor">
<span class="sig-name descname"><span class="pre">pbc_intor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">intor</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kpt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shls_slice</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.pbc_intor" title="Link to this definition"></a></dt>
<dd><p>One-electron integrals with PBC.</p>
<div class="math notranslate nohighlight">
\[\sum_T \int \mu(r) * [intor] * \nu (r-T) dr\]</div>
<p>See also Mole.intor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.post_kernel">
<span class="sig-name descname"><span class="pre">post_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.post_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run after the main body of the kernel function.  Internal
variables are exposed to post_kernel through the “envs” dictionary.
Return value of post_kernel function is not required.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.pre_kernel">
<span class="sig-name descname"><span class="pre">pre_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.pre_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run before the main body of kernel function is executed.
Internal variables are exposed to pre_kernel through the “envs”
dictionary.  Return value of pre_kernel function is not required.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.precision">
<span class="sig-name descname"><span class="pre">precision</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-08</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.precision" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.rcut">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rcut</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.rcut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.rcut_by_shells">
<span class="sig-name descname"><span class="pre">rcut_by_shells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_pgf_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.rcut_by_shells" title="Link to this definition"></a></dt>
<dd><p>Compute shell and primitive gaussian function radii.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.reciprocal_vectors">
<span class="sig-name descname"><span class="pre">reciprocal_vectors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">norm_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6.283185307179586</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.reciprocal_vectors" title="Link to this definition"></a></dt>
<dd><div class="math notranslate nohighlight">
\[\begin{split}\begin{align}
\mathbf{b_1} &amp;= 2\pi \frac{\mathbf{a_2} \times \mathbf{a_3}}{\mathbf{a_1} \cdot (\mathbf{a_2} \times \mathbf{a_3})} \\
\mathbf{b_2} &amp;= 2\pi \frac{\mathbf{a_3} \times \mathbf{a_1}}{\mathbf{a_2} \cdot (\mathbf{a_3} \times \mathbf{a_1})} \\
\mathbf{b_3} &amp;= 2\pi \frac{\mathbf{a_1} \times \mathbf{a_2}}{\mathbf{a_3} \cdot (\mathbf{a_1} \times \mathbf{a_2})}
\end{align}\end{split}\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.reset" title="Link to this definition"></a></dt>
<dd><p>Clean up intermediates</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.run" title="Link to this definition"></a></dt>
<dd><p>Call the kernel function of current object.  <cite>args</cite> will be passed
to kernel function.  <cite>kwargs</cite> will be used to update the attributes of
current object.  The return value of method run is the object itself.
This allows a series of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.search_ao_label">
<span class="sig-name descname"><span class="pre">search_ao_label</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.search_ao_label" title="Link to this definition"></a></dt>
<dd><p>Find the index of the AO basis function based on the given ao_label</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ao_label</strong> – string or a list of strings
The regular expression pattern to match the orbital labels
returned by mol.ao_labels()</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of index for the AOs that matches the given ao_label RE pattern</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl.*p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21 22 23 24 25 26 27 28 29 30]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">(</span><span class="s1">&#39;Cl 2p&#39;</span><span class="p">)</span>
<span class="go">[19 20 21]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_label</span><span class="p">([</span><span class="s1">&#39;Cl.*d&#39;</span><span class="p">,</span> <span class="s1">&#39;Cl 4p&#39;</span><span class="p">])</span>
<span class="go">[25 26 27 31 32 33 34 35 36 37 38 39 40]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.search_ao_nr">
<span class="sig-name descname"><span class="pre">search_ao_nr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmshell</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.search_ao_nr" title="Link to this definition"></a></dt>
<dd><p>Search the first basis function id (<strong>not</strong> the shell id) which matches
the given atom-id, angular momentum magnetic angular momentum, principal shell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atm_id</strong> – int
atom id, 0-based</p></li>
<li><p><strong>l</strong> – int
angular momentum</p></li>
<li><p><strong>m</strong> – int
magnetic angular momentum</p></li>
<li><p><strong>atmshell</strong> – int
principal quantum number</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>basis function id, 0-based.  If not found, return None</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">search_ao_nr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Cl 3px</span>
<span class="go">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.search_ao_r">
<span class="sig-name descname"><span class="pre">search_ao_r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atmshell</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.search_ao_r" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.search_shell_id">
<span class="sig-name descname"><span class="pre">search_shell_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.search_shell_id" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set" title="Link to this definition"></a></dt>
<dd><p>Update the attributes of the current object.  The return value of
method set is the object itself.  This allows a series of
functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_common_orig">
<span class="sig-name descname"><span class="pre">set_common_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_common_orig" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_common_orig_">
<span class="sig-name descname"><span class="pre">set_common_orig_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_common_orig_" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_common_origin">
<span class="sig-name descname"><span class="pre">set_common_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_common_origin" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_common_origin_">
<span class="sig-name descname"><span class="pre">set_common_origin_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_common_origin_" title="Link to this definition"></a></dt>
<dd><p>Update common origin for integrals of dipole, rxp etc.
<strong>Note</strong> the unit of the coordinates needs to be Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_f12_zeta">
<span class="sig-name descname"><span class="pre">set_f12_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_f12_zeta" title="Link to this definition"></a></dt>
<dd><p>Set zeta for YP exp(-zeta r12)/r12 or STG exp(-zeta r12) type integrals</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_geom_">
<span class="sig-name descname"><span class="pre">set_geom_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms_or_coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_geom_" title="Link to this definition"></a></dt>
<dd><p>Update geometry</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_nuc_mod">
<span class="sig-name descname"><span class="pre">set_nuc_mod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_nuc_mod" title="Link to this definition"></a></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_nuc_mod_">
<span class="sig-name descname"><span class="pre">set_nuc_mod_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_nuc_mod_" title="Link to this definition"></a></dt>
<dd><p>Change the nuclear charge distribution of the given atom ID.  The charge
distribution is defined as: rho(r) = nuc_charge * Norm * exp(-zeta * r^2).
This function can <strong>only</strong> be called after .build() method is executed.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">natm</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">zeta</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">filatov_nuc_mod</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">atom_charge</span><span class="p">(</span><span class="n">ia</span><span class="p">))</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">set_nuc_mod</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_range_coulomb">
<span class="sig-name descname"><span class="pre">set_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Switch on range-separated Coulomb operator for <strong>all</strong> 2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>omega</strong> – <p>double</p>
<div class="line-block">
<div class="line">= 0 : Regular electron repulsion integral</div>
<div class="line">&gt; 0 : Long-range operator  erf(omega r12) / r12</div>
<div class="line">&lt; 0 : Short-range operator  erfc(omega r12) /r12</div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_range_coulomb_">
<span class="sig-name descname"><span class="pre">set_range_coulomb_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_range_coulomb_" title="Link to this definition"></a></dt>
<dd><p>Switch on range-separated Coulomb operator for <strong>all</strong> 2e integrals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>omega</strong> – <p>double</p>
<div class="line-block">
<div class="line">= 0 : Regular electron repulsion integral</div>
<div class="line">&gt; 0 : Long-range operator  erf(omega r12) / r12</div>
<div class="line">&lt; 0 : Short-range operator  erfc(omega r12) /r12</div>
</div>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_rinv_orig">
<span class="sig-name descname"><span class="pre">set_rinv_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_rinv_orig" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_rinv_orig_">
<span class="sig-name descname"><span class="pre">set_rinv_orig_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_rinv_orig_" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_rinv_origin">
<span class="sig-name descname"><span class="pre">set_rinv_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_rinv_origin" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_rinv_origin_">
<span class="sig-name descname"><span class="pre">set_rinv_origin_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_rinv_origin_" title="Link to this definition"></a></dt>
<dd><p>Update origin for operator <span class="math notranslate nohighlight">\(\frac{1}{|r-R_O|}\)</span>.
<strong>Note</strong> the unit is Bohr</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span><span class="o">.</span><span class="n">set_rinv_origin</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_rinv_zeta">
<span class="sig-name descname"><span class="pre">set_rinv_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_rinv_zeta" title="Link to this definition"></a></dt>
<dd><p>Assume the charge distribution on the “rinv_origin”.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.set_rinv_zeta_">
<span class="sig-name descname"><span class="pre">set_rinv_zeta_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.set_rinv_zeta_" title="Link to this definition"></a></dt>
<dd><p>Assume the charge distribution on the “rinv_origin”.  zeta is the parameter
to control the charge distribution: rho(r) = Norm * exp(-zeta * r^2).
<strong>Be careful</strong> when call this function. It affects the behavior of
int1e_rinv_* functions.  Make sure to set it back to 0 after using it!</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.space_group_symmetry">
<span class="sig-name descname"><span class="pre">space_group_symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.space_group_symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.sph2spinor_coeff">
<span class="sig-name descname"><span class="pre">sph2spinor_coeff</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.sph2spinor_coeff" title="Link to this definition"></a></dt>
<dd><p>Transformation matrix that transforms real-spherical GTOs to spinor
GTOs for all basis functions</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvtz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ca</span><span class="p">,</span> <span class="n">cb</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">sph2spinor_coeff</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s0</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_spinor&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ca</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">+=</span> <span class="n">cb</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s1</span><span class="o">-</span><span class="n">s0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mf">6.66133814775e-16</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.sph_labels">
<span class="sig-name descname"><span class="pre">sph_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.sph_labels" title="Link to this definition"></a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.spheric_labels">
<span class="sig-name descname"><span class="pre">spheric_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.spheric_labels" title="Link to this definition"></a></dt>
<dd><p>Labels for spherical GTO functions</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><p>fmt : str or bool
if fmt is boolean, it controls whether to format the labels and the
default format is “%d%3s %s%-4s”.  if fmt is string, the string will
be used as the print format.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>List of [(atom-id, symbol-str, nl-str, str-of-real-spherical-notation]
or formatted strings based on the argument “fmt”</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; Cl 0 0 1&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;sto-3g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gto</span><span class="o">.</span><span class="n">sph_labels</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">[(0, &#39;H&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;1s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;2s&#39;, &#39;&#39;), (1, &#39;Cl&#39;, &#39;3s&#39;, &#39;&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;x&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;2p&#39;, &#39;z&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;x&#39;),</span>
<span class="go"> (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;y&#39;), (1, &#39;Cl&#39;, &#39;3p&#39;, &#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.spin">
<span class="sig-name descname"><span class="pre">spin</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.spin" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.spinor_labels">
<span class="sig-name descname"><span class="pre">spinor_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.spinor_labels" title="Link to this definition"></a></dt>
<dd><p>Labels of spinor GTO functions</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.stdout">
<span class="sig-name descname"><span class="pre">stdout</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.stdout" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.symmetrize_mesh">
<span class="sig-name descname"><span class="pre">symmetrize_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.symmetrize_mesh" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.symmetry">
<span class="sig-name descname"><span class="pre">symmetry</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.symmetry_subgroup">
<span class="sig-name descname"><span class="pre">symmetry_subgroup</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.symmetry_subgroup" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.symmorphic">
<span class="sig-name descname"><span class="pre">symmorphic</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.symmorphic" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.time_reversal_map">
<span class="sig-name descname"><span class="pre">time_reversal_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.time_reversal_map" title="Link to this definition"></a></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have positive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math notranslate nohighlight">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math notranslate nohighlight">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.tmap">
<span class="sig-name descname"><span class="pre">tmap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.tmap" title="Link to this definition"></a></dt>
<dd><p>The index to map the spinor functions and its time reversal counterpart.
The returned indices have positive or negative values.  For the i-th basis function,
if the returned j = idx[i] &lt; 0, it means <span class="math notranslate nohighlight">\(T|i\rangle = -|j\rangle\)</span>,
otherwise <span class="math notranslate nohighlight">\(T|i\rangle = |j\rangle\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.to_mol">
<span class="sig-name descname"><span class="pre">to_mol</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.to_mol" title="Link to this definition"></a></dt>
<dd><p>Return a Mole object using the same atoms and basis functions as
the Cell object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.to_uncontracted_cartesian_basis">
<span class="sig-name descname"><span class="pre">to_uncontracted_cartesian_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.to_uncontracted_cartesian_basis" title="Link to this definition"></a></dt>
<dd><p>Decontract the basis of a Mole or a Cell.  Returns a Mole (Cell) object
with uncontracted Cartesian basis and a list of coefficients that
transform the uncontracted basis to the original basis. Each element in
the coefficients list corresponds to one shell of the original Mole (Cell).</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;Ne&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmol</span><span class="p">,</span> <span class="n">ctr_coeff</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">to_uncontracted_cartesian_basis</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">ctr_coeff</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">pmol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">),</span> <span class="n">c</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">0.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.tofile">
<span class="sig-name descname"><span class="pre">tofile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.tofile" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.tostring">
<span class="sig-name descname"><span class="pre">tostring</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'poscar'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.tostring" title="Link to this definition"></a></dt>
<dd><p>Convert cell geometry to a string of the required format.</p>
<dl>
<dt>Supported output formats:</dt><dd><div class="line-block">
<div class="line">poscar: VASP POSCAR</div>
<div class="line">xyz: Extended XYZ with Lattice information</div>
</div>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.tot_electrons">
<span class="sig-name descname"><span class="pre">tot_electrons</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nkpts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.tot_electrons" title="Link to this definition"></a></dt>
<dd><p>Total number of electrons</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.unit">
<span class="sig-name descname"><span class="pre">unit</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'angstrom'</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.unit" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.unpack">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">unpack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moldic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.unpack" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.unpack_">
<span class="sig-name descname"><span class="pre">unpack_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">moldic</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.unpack_" title="Link to this definition"></a></dt>
<dd><p>Convert the packed dict to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object, to generate the
input arguments for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cell</span></code> object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.update" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.update_from_chk">
<span class="sig-name descname"><span class="pre">update_from_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.update_from_chk" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.use_loose_rcut">
<span class="sig-name descname"><span class="pre">use_loose_rcut</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.use_loose_rcut" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.use_particle_mesh_ewald">
<span class="sig-name descname"><span class="pre">use_particle_mesh_ewald</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.use_particle_mesh_ewald" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.verbose" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.view">
<span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.view" title="Link to this definition"></a></dt>
<dd><p>New view of object with the same attributes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.vol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vol</span></span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.vol" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.with_common_orig">
<span class="sig-name descname"><span class="pre">with_common_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.with_common_orig" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.with_common_origin">
<span class="sig-name descname"><span class="pre">with_common_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.with_common_origin" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired common origin.
The required common origin has no effects out of the temporary context.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_common_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_common_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_r&#39;</span><span class="p">,</span> <span class="n">comp</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.with_integral_screen">
<span class="sig-name descname"><span class="pre">with_integral_screen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">threshold</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.with_integral_screen" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the required integral
screen threshold</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.with_long_range_coulomb">
<span class="sig-name descname"><span class="pre">with_long_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.with_long_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context for long-range part of
range-separated Coulomb operator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.with_range_coulomb">
<span class="sig-name descname"><span class="pre">with_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.with_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which sets the required parameter
omega for range-separated Coulomb operator.
If omega = None, return the context for regular Coulomb integrals.
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_range_coulomb()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_range_coulomb</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int2e&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.with_rinv_as_nucleus">
<span class="sig-name descname"><span class="pre">with_rinv_as_nucleus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.with_rinv_as_nucleus" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context in which the rinv operator (1/r) is
treated like the Coulomb potential of a Gaussian charge distribution
rho(r) = Norm * exp(-zeta * r^2) at the place of the input atm_id.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_at_nucleus</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.with_rinv_at_nucleus">
<span class="sig-name descname"><span class="pre">with_rinv_at_nucleus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atm_id</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.with_rinv_at_nucleus" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context in which the rinv operator (1/r) is
treated like the Coulomb potential of a Gaussian charge distribution
rho(r) = Norm * exp(-zeta * r^2) at the place of the input atm_id.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_at_nucleus</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.with_rinv_orig">
<span class="sig-name descname"><span class="pre">with_rinv_orig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.with_rinv_orig" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.with_rinv_origin">
<span class="sig-name descname"><span class="pre">with_rinv_origin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.with_rinv_origin" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired origin of 1/r
operator.  The required origin has no effects out of the temporary
context.  See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_origin()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.with_rinv_zeta">
<span class="sig-name descname"><span class="pre">with_rinv_zeta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zeta</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.with_rinv_zeta" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context which has the rquired Gaussian charge
distribution placed at “rinv_origin”: rho(r) = Norm * exp(-zeta * r^2).
See also <code class="xref py py-func docutils literal notranslate"><span class="pre">mol.set_rinv_zeta()</span></code></p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_zeta</span><span class="p">(</span><span class="n">zeta</span><span class="o">=</span><span class="mf">1.5</span><span class="p">),</span> <span class="n">mol</span><span class="o">.</span><span class="n">with_rinv_origin</span><span class="p">((</span><span class="mf">1.</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_rinv&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.Hubbard2D.with_short_range_coulomb">
<span class="sig-name descname"><span class="pre">with_short_range_coulomb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">omega</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.Hubbard2D.with_short_range_coulomb" title="Link to this definition"></a></dt>
<dd><p>Return a temporary mol context for short-range part of
range-separated Coulomb operator.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.HubbardDF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.latt.</span></span><span class="sig-name descname"><span class="pre">HubbardDF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#HubbardDF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.HubbardDF" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.HubbardDF.ao2mo">
<span class="sig-name descname"><span class="pre">ao2mo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#HubbardDF.ao2mo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.HubbardDF.ao2mo" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.HubbardDF.get_naoaux">
<span class="sig-name descname"><span class="pre">get_naoaux</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#HubbardDF.get_naoaux"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.HubbardDF.get_naoaux" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.HubbardDF.loop">
<span class="sig-name descname"><span class="pre">loop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blksize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#HubbardDF.loop"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.HubbardDF.loop" title="Link to this definition"></a></dt>
<dd><p>Note that blksize is ignored.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeSCF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.latt.</span></span><span class="sig-name descname"><span class="pre">LatticeSCF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeSCF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeSCF" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeSCF.cell">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cell</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeSCF.cell" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeSCF.get_hcore">
<span class="sig-name descname"><span class="pre">get_hcore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeSCF.get_hcore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeSCF.get_hcore" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeSCF.get_ovlp">
<span class="sig-name descname"><span class="pre">get_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeSCF.get_ovlp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeSCF.get_ovlp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeSCF.density_fit">
<span class="sig-name descname"><span class="pre">density_fit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeSCF.density_fit"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeSCF.density_fit" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.latt.</span></span><span class="sig-name descname"><span class="pre">LatticeRHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeRHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#vayesta.lattmod.latt.LatticeSCF" title="vayesta.lattmod.latt.LatticeSCF"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatticeSCF</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RHF</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.get_init_guess">
<span class="sig-name descname"><span class="pre">get_init_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeRHF.get_init_guess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.get_init_guess" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.get_jk">
<span class="sig-name descname"><span class="pre">get_jk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeRHF.get_jk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.get_jk" title="Link to this definition"></a></dt>
<dd><p>Compute J, K matrices for all input density matrices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – ndarray or list of ndarrays
A density matrix or a list of density matrices</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : not hermitian and not symmetric</div>
<div class="line">1 : hermitian or symmetric</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
<dt>with_j<span class="classifier">boolean</span></dt><dd><p>Whether to compute J matrices</p>
</dd>
<dt>with_k<span class="classifier">boolean</span></dt><dd><p>Whether to compute K matrices</p>
</dd>
<dt>omega<span class="classifier">float</span></dt><dd><p>Parameter of range-separated Coulomb operator.
When omega is 0 (or None), integrals are computed with the full-range Coulomb potential.
When it is larger than zero, integrals are evaluated with the long-range
Coulomb potential erf( omega * r12 ) / r12. When omega is smaller
than 0, short-range Coulomb potential erfc( omega * r12 ) / r12 is applied.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Depending on the given dm, the function returns one J and one K matrix,
or a list of J matrices and a list of K matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf.scf</span><span class="w"> </span><span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_jk</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.check_lattice_symmetry">
<span class="sig-name descname"><span class="pre">check_lattice_symmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeRHF.check_lattice_symmetry"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.check_lattice_symmetry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.CCSD">
<span class="sig-name descname"><span class="pre">CCSD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frozen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.CCSD" title="Link to this definition"></a></dt>
<dd><p>restricted CCSD</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.verbose" title="Link to this definition"></a></dt>
<dd><p>int
Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.max_memory">
<span class="sig-name descname"><span class="pre">max_memory</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.max_memory" title="Link to this definition"></a></dt>
<dd><p>float or int
Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.conv_tol">
<span class="sig-name descname"><span class="pre">conv_tol</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.conv_tol" title="Link to this definition"></a></dt>
<dd><p>float
converge threshold.  Default is 1e-7.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.conv_tol_normt">
<span class="sig-name descname"><span class="pre">conv_tol_normt</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.conv_tol_normt" title="Link to this definition"></a></dt>
<dd><p>float
converge threshold for norm(t1,t2).  Default is 1e-5.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.max_cycle">
<span class="sig-name descname"><span class="pre">max_cycle</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.max_cycle" title="Link to this definition"></a></dt>
<dd><p>int
max number of iterations.  Default is 50.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.diis_space">
<span class="sig-name descname"><span class="pre">diis_space</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.diis_space" title="Link to this definition"></a></dt>
<dd><p>int
DIIS space size.  Default is 6.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.diis_start_cycle">
<span class="sig-name descname"><span class="pre">diis_start_cycle</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.diis_start_cycle" title="Link to this definition"></a></dt>
<dd><p>int
The step to start DIIS.  Default is 0.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.iterative_damping">
<span class="sig-name descname"><span class="pre">iterative_damping</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.iterative_damping" title="Link to this definition"></a></dt>
<dd><p>float
The self consistent damping parameter.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.direct" title="Link to this definition"></a></dt>
<dd><p>bool
AO-direct CCSD. Default is False.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.async_io">
<span class="sig-name descname"><span class="pre">async_io</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.async_io" title="Link to this definition"></a></dt>
<dd><p>bool
Allow for asynchronous function execution. Default is True.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.incore_complete">
<span class="sig-name descname"><span class="pre">incore_complete</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.incore_complete" title="Link to this definition"></a></dt>
<dd><p>bool
Avoid all I/O (also for DIIS). Default is False.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.level_shift">
<span class="sig-name descname"><span class="pre">level_shift</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.level_shift" title="Link to this definition"></a></dt>
<dd><p>float
A shift on virtual orbital energies to stabilize the CCSD iteration</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.frozen">
<span class="sig-name descname"><span class="pre">frozen</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.frozen" title="Link to this definition"></a></dt>
<dd><p>int or list
If integer is given, the inner-most orbitals are frozen from CC
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in CC calculation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># auto-generate the number of core orbitals to be frozen (1 in this case)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set_frozen</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.callback">
<span class="sig-name descname"><span class="pre">callback</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.callback" title="Link to this definition"></a></dt>
<dd><p>function(envs_dict) =&gt; None
callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd></dl>

<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the CCSD iteration converged</p>
</dd>
<dt>e_corr<span class="classifier">float</span></dt><dd><p>CCSD correlation correction</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total CCSD energy (HF + correlation)</p>
</dd>
<dt>t1, t2 :</dt><dd><p>T amplitudes t1[i,a], t2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
<dt>l1, l2 :</dt><dd><p>Lambda amplitudes l1[i,a], l2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.CISD">
<span class="sig-name descname"><span class="pre">CISD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.CISD" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.DFCCSD">
<span class="sig-name descname"><span class="pre">DFCCSD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.DFCCSD" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.DFMP2">
<span class="sig-name descname"><span class="pre">DFMP2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.DFMP2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.DIIS">
<span class="sig-name descname"><span class="pre">DIIS</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.DIIS" title="Link to this definition"></a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">CDIIS</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.MP2">
<span class="sig-name descname"><span class="pre">MP2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.MP2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.QCISD">
<span class="sig-name descname"><span class="pre">QCISD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frozen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.QCISD" title="Link to this definition"></a></dt>
<dd><p>restricted QCISD</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.analyze" title="Link to this definition"></a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.apply" title="Link to this definition"></a></dt>
<dd><p>Apply the fn to rest arguments:  return <code class="docutils literal notranslate"><span class="pre">fn(*args,</span> <span class="pre">**kwargs)</span></code>.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.as_scanner">
<span class="sig-name descname"><span class="pre">as_scanner</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.as_scanner" title="Link to this definition"></a></dt>
<dd><p>Generating a scanner/solver for HF PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total HF energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
SCF object (DIIS, conv_tol, max_memory etc) are automatically applied in
the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="go">-98.552190448277955</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
<span class="go">-98.414750424294368</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.build" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id0">
<span class="sig-name descname"><span class="pre">callback</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#id0" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.canonicalize" title="Link to this definition"></a></dt>
<dd><p>Canonicalization diagonalizes the Fock matrix within occupied, open,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.cell">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cell</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.cell" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.check_convergence">
<span class="sig-name descname"><span class="pre">check_convergence</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.check_convergence" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.check_sanity">
<span class="sig-name descname"><span class="pre">check_sanity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.check_sanity" title="Link to this definition"></a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.conv_check">
<span class="sig-name descname"><span class="pre">conv_check</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.conv_check" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id9">
<span class="sig-name descname"><span class="pre">conv_tol</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-09</span></em><a class="headerlink" href="#id9" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.conv_tol_cpscf">
<span class="sig-name descname"><span class="pre">conv_tol_cpscf</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-08</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.conv_tol_cpscf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.conv_tol_grad">
<span class="sig-name descname"><span class="pre">conv_tol_grad</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.conv_tol_grad" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.convert_from_">
<span class="sig-name descname"><span class="pre">convert_from_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.convert_from_" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to RHF/ROHF</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.copy" title="Link to this definition"></a></dt>
<dd><p>Returns a shallow copy</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.damp">
<span class="sig-name descname"><span class="pre">damp</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.damp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.density_fit">
<span class="sig-name descname"><span class="pre">density_fit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.density_fit" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.diis">
<span class="sig-name descname"><span class="pre">diis</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.diis" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.diis_damp">
<span class="sig-name descname"><span class="pre">diis_damp</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.diis_damp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.diis_file">
<span class="sig-name descname"><span class="pre">diis_file</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.diis_file" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id10">
<span class="sig-name descname"><span class="pre">diis_space</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">8</span></em><a class="headerlink" href="#id10" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.diis_space_rollback">
<span class="sig-name descname"><span class="pre">diis_space_rollback</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.diis_space_rollback" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id11">
<span class="sig-name descname"><span class="pre">diis_start_cycle</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#id11" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.dip_moment">
<span class="sig-name descname"><span class="pre">dip_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Debye'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.dip_moment" title="Link to this definition"></a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – a 2D ndarrays density matrices</p></li>
<li><p><strong>origin</strong> – optional; length 3 list, tuple, or 1D array
Location of the origin. By default, the point (0, 0, 0) is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the dipole moment on x, y and z component</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.direct_scf">
<span class="sig-name descname"><span class="pre">direct_scf</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.direct_scf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.direct_scf_tol">
<span class="sig-name descname"><span class="pre">direct_scf_tol</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-13</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.direct_scf_tol" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.disp">
<span class="sig-name descname"><span class="pre">disp</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.disp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.do_disp">
<span class="sig-name descname"><span class="pre">do_disp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.do_disp" title="Link to this definition"></a></dt>
<dd><p>Check whether to apply dispersion correction based on the xc attribute.
If dispersion is allowed, return the DFTD3 disp version, such as d3bj,
d3zero, d4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.dump_chk">
<span class="sig-name descname"><span class="pre">dump_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs_or_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.dump_chk" title="Link to this definition"></a></dt>
<dd><p>Serialize the SCF object and save it to the specified chkfile.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>envs_or_file</strong> – If this argument is a file path, the serialized SCF object is
saved to the file specified by this argument.
If this attribute is a dict (created by locals()), the necessary
variables are saved to the file specified by the attribute mf.chkfile.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.dump_flags">
<span class="sig-name descname"><span class="pre">dump_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.dump_flags" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.dump_scf_summary">
<span class="sig-name descname"><span class="pre">dump_scf_summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.dump_scf_summary" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.eig" title="Link to this definition"></a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.energy_elec">
<span class="sig-name descname"><span class="pre">energy_elec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.energy_elec" title="Link to this definition"></a></dt>
<dd><p>Electronic part of Hartree-Fock energy, for given core hamiltonian and
HF potential</p>
<div class="math notranslate nohighlight">
\[E = \sum_{ij}h_{ij} \gamma_{ji}
  + \frac{1}{2}\sum_{ijkl} \gamma_{ji}\gamma_{lk} \langle ik||jl\rangle\]</div>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mf</strong> – an instance of SCF class</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm<span class="classifier">2D ndarray</span></dt><dd><p>one-particle density matrix</p>
</dd>
<dt>h1e<span class="classifier">2D ndarray</span></dt><dd><p>Core hamiltonian</p>
</dd>
<dt>vhf<span class="classifier">2D ndarray</span></dt><dd><p>HF potential</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Hartree-Fock electronic energy and the Coulomb energy</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">scf</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm</span> <span class="o">=</span> <span class="n">mf</span><span class="o">.</span><span class="n">make_rdm1</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">energy_elec</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
<span class="go">(-1.5176090667746334, 0.60917167853723675)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.energy_nuc">
<span class="sig-name descname"><span class="pre">energy_nuc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.energy_nuc" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.energy_tot">
<span class="sig-name descname"><span class="pre">energy_tot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.energy_tot" title="Link to this definition"></a></dt>
<dd><p>Total Hartree-Fock energy, electronic part plus nuclear repulsion
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.energy_elec()</span></code> for the electron part</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.from_chk">
<span class="sig-name descname"><span class="pre">from_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.from_chk" title="Link to this definition"></a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.gen_response">
<span class="sig-name descname"><span class="pre">gen_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">singlet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_nlc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.gen_response" title="Link to this definition"></a></dt>
<dd><p>Generate a function to compute the product of RHF response function and
RHF density matrices.</p>
<dl>
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>singlet (None or boolean)<span class="classifier">If singlet is None, response function for</span></dt><dd><p>orbital hessian or CPHF will be generated. If singlet is boolean,
it is used in TDDFT response kernel.</p>
</dd>
</dl>
<p>with_nlc (boolean) : NLC contribution is typically very small. This flag
allows to skip NLC contribution.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.get_dispersion">
<span class="sig-name descname"><span class="pre">get_dispersion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_3body</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.get_dispersion" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.get_fock">
<span class="sig-name descname"><span class="pre">get_fock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis_start_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damp_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.get_fock" title="Link to this definition"></a></dt>
<dd><p>F = h^{core} + V^{HF}</p>
<p>Special treatment (damping, DIIS, or level shift) will be applied to the
Fock matrix if diis and cycle is specified (The two parameters are passed
to get_fock function during the SCF iteration)</p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>h1e<span class="classifier">2D ndarray</span></dt><dd><p>Core hamiltonian</p>
</dd>
<dt>s1e<span class="classifier">2D ndarray</span></dt><dd><p>Overlap matrix, for DIIS</p>
</dd>
<dt>vhf<span class="classifier">2D ndarray</span></dt><dd><p>HF potential matrix</p>
</dd>
<dt>dm<span class="classifier">2D ndarray</span></dt><dd><p>Density matrix, for DIIS</p>
</dd>
<dt>cycle<span class="classifier">int</span></dt><dd><p>Then present SCF iteration step, for DIIS</p>
</dd>
<dt>diis<span class="classifier">an object of <code class="xref py py-attr docutils literal notranslate"><span class="pre">SCF.DIIS</span></code> class</span></dt><dd><p>DIIS object to hold intermediate Fock and error vectors</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 0.</p>
</dd>
<dt>level_shift_factor<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.get_grad" title="Link to this definition"></a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mo_coeff</strong> – 2D ndarray
Obital coefficients</p></li>
<li><p><strong>mo_occ</strong> – 1D ndarray
Orbital occupancy</p></li>
<li><p><strong>fock_ao</strong> – 2D ndarray
Fock matrix in AO representation</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.get_hcore">
<span class="sig-name descname"><span class="pre">get_hcore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.get_hcore" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.get_j">
<span class="sig-name descname"><span class="pre">get_j</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.get_j" title="Link to this definition"></a></dt>
<dd><p>Compute J matrices for all input density matrices</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.get_k">
<span class="sig-name descname"><span class="pre">get_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.get_k" title="Link to this definition"></a></dt>
<dd><p>Compute K matrices for all input density matrices</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.get_occ" title="Link to this definition"></a></dt>
<dd><p>Label the occupancies for each orbital</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">1D ndarray</span></dt><dd><p>Obital energies</p>
</dd>
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 0, 2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.get_ovlp">
<span class="sig-name descname"><span class="pre">get_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.get_ovlp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.get_veff">
<span class="sig-name descname"><span class="pre">get_veff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.get_veff" title="Link to this definition"></a></dt>
<dd><p>Hartree-Fock potential matrix for the given density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – ndarray or list of ndarrays
A density matrix or a list of density matrices</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>dm_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The density matrix baseline.  If not 0, this function computes the
increment of HF potential w.r.t. the reference HF potential matrix.</p>
</dd>
<dt>vhf_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The reference HF potential matrix.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>matrix Vhf = 2*J - K.  Vhf can be a list matrices, corresponding to the
input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf.scf</span><span class="w"> </span><span class="kn">import</span> <span class="n">_vhf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm0</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf0</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dm1</span><span class="p">,</span> <span class="n">dm_last</span><span class="o">=</span><span class="n">dm0</span><span class="p">,</span> <span class="n">vhf_last</span><span class="o">=</span><span class="n">vhf0</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numpy</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">vhf1</span><span class="p">,</span> <span class="n">vhf2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.init_direct_scf">
<span class="sig-name descname"><span class="pre">init_direct_scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.init_direct_scf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.init_guess">
<span class="sig-name descname"><span class="pre">init_guess</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'minao'</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.init_guess" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.init_guess_by_1e">
<span class="sig-name descname"><span class="pre">init_guess_by_1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.init_guess_by_1e" title="Link to this definition"></a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.init_guess_by_atom">
<span class="sig-name descname"><span class="pre">init_guess_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.init_guess_by_atom" title="Link to this definition"></a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.init_guess_by_chkfile">
<span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.init_guess_by_chkfile" title="Link to this definition"></a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.init_guess_by_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.init_guess_by_huckel" title="Link to this definition"></a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.init_guess_by_minao">
<span class="sig-name descname"><span class="pre">init_guess_by_minao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.init_guess_by_minao" title="Link to this definition"></a></dt>
<dd><p>Generate initial guess density matrix based on ANO basis, then project
the density matrix to the basis set defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">init_guess_by_minao</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="go">array([[ 0.94758917,  0.09227308],</span>
<span class="go">       [ 0.09227308,  0.94758917]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.init_guess_by_mod_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_mod_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">updated_rule</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.init_guess_by_mod_huckel" title="Link to this definition"></a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<p>In contrast to init_guess_by_huckel, this routine employs the
updated GWH rule from doi:10.1021/ja00480a005 to form the guess.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.init_guess_by_sap">
<span class="sig-name descname"><span class="pre">init_guess_by_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.init_guess_by_sap" title="Link to this definition"></a></dt>
<dd><p>Generate initial guess density matrix from a superposition of
atomic potentials (SAP), doi:10.1021/acs.jctc.8b01089.
This is the Gaussian fit implementation, see doi:10.1063/5.0004046.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – MoleBase object
the molecule object for which the initial guess is evaluated</p></li>
<li><p><strong>sap_basis</strong> – dict
SAP basis in internal format (python dictionary)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>ndarray</dt><dd><p>SAP initial guess density matrix</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dm0</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.istype">
<span class="sig-name descname"><span class="pre">istype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type_code</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.istype" title="Link to this definition"></a></dt>
<dd><p>Checks if the object is an instance of the class specified by the type_code.
type_code can be a class or a str. If the type_code is a class, it is
equivalent to the Python built-in function <cite>isinstance</cite>. If the type_code
is a str, it checks the type_code against the names of the object and all
its parent classes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.kernel">
<span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.kernel" title="Link to this definition"></a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id12">
<span class="sig-name descname"><span class="pre">level_shift</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#id12" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.make_rdm1">
<span class="sig-name descname"><span class="pre">make_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.make_rdm1" title="Link to this definition"></a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mo_coeff</strong> – 2D ndarray
Orbital coefficients. Each column is one orbital.</p></li>
<li><p><strong>mo_occ</strong> – 1D ndarray
Occupancy</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>One-particle density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.make_rdm2">
<span class="sig-name descname"><span class="pre">make_rdm2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.make_rdm2" title="Link to this definition"></a></dt>
<dd><p>Two-particle density matrix in AO representation</p>
<blockquote>
<div><p>NOTE the indices of the two-particle density matrix is ordered to</p>
<p>dm2[p,q,r,s] = &lt;q^+ s^+ r p&gt;.</p>
<p>HF energy can be computed
E = einsum(‘pq,qp’, hcore, 1pdm) + einsum(‘pqrs,pqrs’, eri, 2pdm) / 2
where h1[p,q] = &lt;p|h|q&gt; and eri[p,q,r,s] = (pq|rs)</p>
</div></blockquote>
<dl>
<dt>to make the density matrix consistent with the density matrix obtained</dt><dd><p>from post-HF methods,</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Orbital coefficients. Each column is one orbital.</p>
</dd>
<dt>mo_occ<span class="classifier">1D ndarray</span></dt><dd><p>Occupancy</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>Two-particle density matrix, 4D ndarray</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id13">
<span class="sig-name descname"><span class="pre">max_cycle</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">50</span></em><a class="headerlink" href="#id13" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.mulliken_meta">
<span class="sig-name descname"><span class="pre">mulliken_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.mulliken_meta" title="Link to this definition"></a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – ndarray or 2-item list of ndarray
Density matrix.  ROHF dm is a 2-item list of 2D array</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.mulliken_pop">
<span class="sig-name descname"><span class="pre">mulliken_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.mulliken_pop" title="Link to this definition"></a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.mulliken_pop_meta_lowdin_ao">
<span class="sig-name descname"><span class="pre">mulliken_pop_meta_lowdin_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.mulliken_pop_meta_lowdin_ao" title="Link to this definition"></a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – ndarray or 2-item list of ndarray
Density matrix.  ROHF dm is a 2-item list of 2D array</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.multigrid_numint">
<span class="sig-name descname"><span class="pre">multigrid_numint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">margin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.multigrid_numint" title="Link to this definition"></a></dt>
<dd><p>Apply the MultiGrid algorithm for XC numerical integartion.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>margin<span class="classifier">float</span></dt><dd><p>A box will be created to enclose the molecule, with the molecule
positioned at the center. “margin” specifies the distance from
the edge of the molecule to the edge of the box. If not provided,
a default margin is estimated, which ensures that the electron
density decays to approximately 1e-7 at the boundary of the box.</p>
</dd>
<dt>mesh<span class="classifier">(3,) ndarray</span></dt><dd><p>The number of mesh grids along each axis. If not specified, the
number of mesh grids will be estimated based on the basis sets
and the margin.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.newton">
<span class="sig-name descname"><span class="pre">newton</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.newton" title="Link to this definition"></a></dt>
<dd><p>Create an SOSCF object based on the mean-field object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.nuc_grad_method">
<span class="sig-name descname"><span class="pre">nuc_grad_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.nuc_grad_method" title="Link to this definition"></a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.opt">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">opt</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.opt" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.pop" title="Link to this definition"></a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – ndarray or 2-item list of ndarray
Density matrix.  ROHF dm is a 2-item list of 2D array</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.post_kernel">
<span class="sig-name descname"><span class="pre">post_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.post_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run after the main body of the kernel function.  Internal
variables are exposed to post_kernel through the “envs” dictionary.
Return value of post_kernel function is not required.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.pre_kernel">
<span class="sig-name descname"><span class="pre">pre_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.pre_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run before the main body of kernel function is executed.
Internal variables are exposed to pre_kernel through the “envs”
dictionary.  Return value of pre_kernel function is not required.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.quad_moment">
<span class="sig-name descname"><span class="pre">quad_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DebyeAngstrom'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.quad_moment" title="Link to this definition"></a></dt>
<dd><p>Calculates traceless quadrupole moment tensor.</p>
<p>The traceless quadrupole tensor is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}Q_{ij} &amp;= - \frac{1}{2} \sum_{\mu \nu} P_{\mu \nu}
        \left[ 3 (\nu | r_i r_j | \mu) - \delta_{ij} (\nu | r^2 | \mu) \right] \\
       &amp;+ \frac{1}{2} \sum_A Q_A
       \left( R_{iA} R_{jA} - \delta_{ij} \|\mathbf{R}_A\|^2  \right).\end{split}\]</div>
<p>If the molecule has a dipole, the quadrupole moment depends on the location
of the origin. By default, the origin is taken to be (0, 0, 0), but it can
be set manually via the keyword argument <cite>origin</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – a 2D ndarrays density matrices</p></li>
<li><p><strong>origin</strong> – optional; length 3 list, tuple, or 1D array
Location of the origin. By default, it is (0, 0, 0).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Traceless quadrupole tensor, 2D ndarray.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.remove_soscf">
<span class="sig-name descname"><span class="pre">remove_soscf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.remove_soscf" title="Link to this definition"></a></dt>
<dd><p>Remove the SOSCF decorator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.reset" title="Link to this definition"></a></dt>
<dd><p>Reset mol and relevant attributes associated to the old mol object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.run" title="Link to this definition"></a></dt>
<dd><p>Call the kernel function of current object.  <cite>args</cite> will be passed
to kernel function.  <cite>kwargs</cite> will be used to update the attributes of
current object.  The return value of method run is the object itself.
This allows a series of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.sap_basis">
<span class="sig-name descname"><span class="pre">sap_basis</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'sapgrasplarge'</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.sap_basis" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.scf" title="Link to this definition"></a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.set" title="Link to this definition"></a></dt>
<dd><p>Update the attributes of the current object.  The return value of
method set is the object itself.  This allows a series of
functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.sfx2c1e">
<span class="sig-name descname"><span class="pre">sfx2c1e</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.sfx2c1e" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.spin_square">
<span class="sig-name descname"><span class="pre">spin_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.spin_square" title="Link to this definition"></a></dt>
<dd><p>Spin square and multiplicity of RHF determinant</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.stability">
<span class="sig-name descname"><span class="pre">stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.stability" title="Link to this definition"></a></dt>
<dd><p>RHF/RKS stability analysis.</p>
<p>See also pyscf.scf.stability.rhf_stability function.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the RHF optimization space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the RHF -&gt; UHF and real -&gt; complex
stability analysis.</p>
</dd>
<dt>return_status: bool</dt><dd><p>Whether to return <cite>stable_i</cite> and <cite>stable_e</cite></p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>If return_status is False (default), the return value includes
two set of orbitals, which are more close to the stable condition.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
<p>Else, another two boolean variables (indicating current status:
stable or unstable) are returned.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.stdout">
<span class="sig-name descname"><span class="pre">stdout</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.stdout" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.to_ghf">
<span class="sig-name descname"><span class="pre">to_ghf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.to_ghf" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a GHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.to_gks">
<span class="sig-name descname"><span class="pre">to_gks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.to_gks" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a GKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.to_gpu" title="Link to this definition"></a></dt>
<dd><p>Convert a method to its corresponding GPU variant, and recursively
converts all attributes of a method to cupy objects or gpu4pyscf objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.to_ks">
<span class="sig-name descname"><span class="pre">to_ks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.to_ks" title="Link to this definition"></a></dt>
<dd><p>Convert to RKS object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.to_rhf">
<span class="sig-name descname"><span class="pre">to_rhf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.to_rhf" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a RHF/ROHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.to_rks">
<span class="sig-name descname"><span class="pre">to_rks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.to_rks" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a RKS/ROKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.to_uhf">
<span class="sig-name descname"><span class="pre">to_uhf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.to_uhf" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a UHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.to_uks">
<span class="sig-name descname"><span class="pre">to_uks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.to_uks" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a UKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.update" title="Link to this definition"></a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id30"><span class="problematic" id="id31">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.update_">
<span class="sig-name descname"><span class="pre">update_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.update_" title="Link to this definition"></a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id32"><span class="problematic" id="id33">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.update_from_chk">
<span class="sig-name descname"><span class="pre">update_from_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.update_from_chk" title="Link to this definition"></a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id34"><span class="problematic" id="id35">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.update_from_chk_">
<span class="sig-name descname"><span class="pre">update_from_chk_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.update_from_chk_" title="Link to this definition"></a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id36"><span class="problematic" id="id37">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id14">
<span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#id14" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.view">
<span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.view" title="Link to this definition"></a></dt>
<dd><p>New view of object with the same attributes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.x2c">
<span class="sig-name descname"><span class="pre">x2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.x2c" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeRHF.x2c1e">
<span class="sig-name descname"><span class="pre">x2c1e</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeRHF.x2c1e" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.latt.</span></span><span class="sig-name descname"><span class="pre">LatticeUHF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeUHF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#vayesta.lattmod.latt.LatticeSCF" title="vayesta.lattmod.latt.LatticeSCF"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatticeSCF</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">UHF</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.get_init_guess">
<span class="sig-name descname"><span class="pre">get_init_guess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeUHF.get_init_guess"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.get_init_guess" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.get_jk">
<span class="sig-name descname"><span class="pre">get_jk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod/latt.html#LatticeUHF.get_jk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.get_jk" title="Link to this definition"></a></dt>
<dd><p>Coulomb (J) and exchange (K)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dm</strong> – a list of 2D arrays or a list of 3D arrays
(alpha_dm, beta_dm) or (alpha_dms, beta_dms)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.CCSD">
<span class="sig-name descname"><span class="pre">CCSD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frozen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.CCSD" title="Link to this definition"></a></dt>
<dd><p>restricted CCSD</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.verbose">
<span class="sig-name descname"><span class="pre">verbose</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.verbose" title="Link to this definition"></a></dt>
<dd><p>int
Print level.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.verbose</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.max_memory">
<span class="sig-name descname"><span class="pre">max_memory</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.max_memory" title="Link to this definition"></a></dt>
<dd><p>float or int
Allowed memory in MB.  Default value equals to <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole.max_memory</span></code></p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.conv_tol">
<span class="sig-name descname"><span class="pre">conv_tol</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.conv_tol" title="Link to this definition"></a></dt>
<dd><p>float
converge threshold.  Default is 1e-7.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.conv_tol_normt">
<span class="sig-name descname"><span class="pre">conv_tol_normt</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.conv_tol_normt" title="Link to this definition"></a></dt>
<dd><p>float
converge threshold for norm(t1,t2).  Default is 1e-5.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.max_cycle">
<span class="sig-name descname"><span class="pre">max_cycle</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.max_cycle" title="Link to this definition"></a></dt>
<dd><p>int
max number of iterations.  Default is 50.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.diis_space">
<span class="sig-name descname"><span class="pre">diis_space</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.diis_space" title="Link to this definition"></a></dt>
<dd><p>int
DIIS space size.  Default is 6.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.diis_start_cycle">
<span class="sig-name descname"><span class="pre">diis_start_cycle</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.diis_start_cycle" title="Link to this definition"></a></dt>
<dd><p>int
The step to start DIIS.  Default is 0.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.iterative_damping">
<span class="sig-name descname"><span class="pre">iterative_damping</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.iterative_damping" title="Link to this definition"></a></dt>
<dd><p>float
The self consistent damping parameter.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.direct">
<span class="sig-name descname"><span class="pre">direct</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.direct" title="Link to this definition"></a></dt>
<dd><p>bool
AO-direct CCSD. Default is False.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.async_io">
<span class="sig-name descname"><span class="pre">async_io</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.async_io" title="Link to this definition"></a></dt>
<dd><p>bool
Allow for asynchronous function execution. Default is True.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.incore_complete">
<span class="sig-name descname"><span class="pre">incore_complete</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.incore_complete" title="Link to this definition"></a></dt>
<dd><p>bool
Avoid all I/O (also for DIIS). Default is False.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.level_shift">
<span class="sig-name descname"><span class="pre">level_shift</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.level_shift" title="Link to this definition"></a></dt>
<dd><p>float
A shift on virtual orbital energies to stabilize the CCSD iteration</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.frozen">
<span class="sig-name descname"><span class="pre">frozen</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.frozen" title="Link to this definition"></a></dt>
<dd><p>int or list
If integer is given, the inner-most orbitals are frozen from CC
amplitudes.  Given the orbital indices (0-based) in a list, both
occupied and virtual orbitals can be frozen in CC calculation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span> <span class="o">=</span> <span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">,</span> <span class="n">basis</span> <span class="o">=</span> <span class="s1">&#39;ccpvdz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># auto-generate the number of core orbitals to be frozen (1 in this case)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span> <span class="o">=</span> <span class="n">cc</span><span class="o">.</span><span class="n">CCSD</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span><span class="o">.</span><span class="n">set_frozen</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># freeze 2 core orbitals and 3 high lying unoccupied orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mycc</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">frozen</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">])</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.callback">
<span class="sig-name descname"><span class="pre">callback</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.callback" title="Link to this definition"></a></dt>
<dd><p>function(envs_dict) =&gt; None
callback function takes one dict as the argument which is
generated by the builtin function <code class="xref py py-func docutils literal notranslate"><span class="pre">locals()</span></code>, so that the
callback function can access all local variables in the current
environment.</p>
</dd></dl>

<p>Saved results:</p>
<blockquote>
<div><dl class="simple">
<dt>converged<span class="classifier">bool</span></dt><dd><p>Whether the CCSD iteration converged</p>
</dd>
<dt>e_corr<span class="classifier">float</span></dt><dd><p>CCSD correlation correction</p>
</dd>
<dt>e_tot<span class="classifier">float</span></dt><dd><p>Total CCSD energy (HF + correlation)</p>
</dd>
<dt>t1, t2 :</dt><dd><p>T amplitudes t1[i,a], t2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
<dt>l1, l2 :</dt><dd><p>Lambda amplitudes l1[i,a], l2[i,j,a,b]  (i,j in occ, a,b in virt)</p>
</dd>
<dt>cycles<span class="classifier">int</span></dt><dd><p>The number of iteration cycles performed</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.CISD">
<span class="sig-name descname"><span class="pre">CISD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.CISD" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.DFMP2">
<span class="sig-name descname"><span class="pre">DFMP2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.DFMP2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.DIIS">
<span class="sig-name descname"><span class="pre">DIIS</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.DIIS" title="Link to this definition"></a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">CDIIS</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.MP2">
<span class="sig-name descname"><span class="pre">MP2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.MP2" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.QCISD">
<span class="sig-name descname"><span class="pre">QCISD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frozen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.QCISD" title="Link to this definition"></a></dt>
<dd><p>restricted QCISD</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.analyze">
<span class="sig-name descname"><span class="pre">analyze</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_meta_lowdin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.analyze" title="Link to this definition"></a></dt>
<dd><p>Analyze the given SCF object:  print orbital energies, occupancies;
print orbital coefficients; Mulliken population analysis; Diople moment.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.apply" title="Link to this definition"></a></dt>
<dd><p>Apply the fn to rest arguments:  return <code class="docutils literal notranslate"><span class="pre">fn(*args,</span> <span class="pre">**kwargs)</span></code>.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.as_scanner">
<span class="sig-name descname"><span class="pre">as_scanner</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.as_scanner" title="Link to this definition"></a></dt>
<dd><p>Generating a scanner/solver for HF PES.</p>
<p>The returned solver is a function. This function requires one argument
“mol” as input and returns total HF energy.</p>
<p>The solver will automatically use the results of last calculation as the
initial guess of the new calculation.  All parameters assigned in the
SCF object (DIIS, conv_tol, max_memory etc) are automatically applied in
the solver.</p>
<p>Note scanner has side effects.  It may change many underlying objects
(_scf, with_df, with_x2c, …) during calculation.</p>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">as_scanner</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">))</span>
<span class="go">-98.552190448277955</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hf_scanner</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.5&#39;</span><span class="p">))</span>
<span class="go">-98.414750424294368</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.build" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id15">
<span class="sig-name descname"><span class="pre">callback</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#id15" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.canonicalize">
<span class="sig-name descname"><span class="pre">canonicalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.canonicalize" title="Link to this definition"></a></dt>
<dd><p>Canonicalization diagonalizes the UHF Fock matrix within occupied,
virtual subspaces separatedly (without change occupancy).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.cell">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cell</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.cell" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.check_convergence">
<span class="sig-name descname"><span class="pre">check_convergence</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.check_convergence" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.check_sanity">
<span class="sig-name descname"><span class="pre">check_sanity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.check_sanity" title="Link to this definition"></a></dt>
<dd><p>Check input of class/object attributes, check whether a class method is
overwritten.  It does not check the attributes which are prefixed with
“_”.  The
return value of method set is the object itself.  This allows a series
of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.conv_check">
<span class="sig-name descname"><span class="pre">conv_check</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.conv_check" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id16">
<span class="sig-name descname"><span class="pre">conv_tol</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-09</span></em><a class="headerlink" href="#id16" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.conv_tol_cpscf">
<span class="sig-name descname"><span class="pre">conv_tol_cpscf</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-08</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.conv_tol_cpscf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.conv_tol_grad">
<span class="sig-name descname"><span class="pre">conv_tol_grad</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.conv_tol_grad" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.convert_from_">
<span class="sig-name descname"><span class="pre">convert_from_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.convert_from_" title="Link to this definition"></a></dt>
<dd><p>Create UHF object based on the RHF/ROHF object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.copy" title="Link to this definition"></a></dt>
<dd><p>Returns a shallow copy</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.damp">
<span class="sig-name descname"><span class="pre">damp</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.damp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.density_fit">
<span class="sig-name descname"><span class="pre">density_fit</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.density_fit" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.det_ovlp">
<span class="sig-name descname"><span class="pre">det_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ovlp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.det_ovlp" title="Link to this definition"></a></dt>
<dd><p>Calculate the overlap between two different determinants. It is the product
of single values of molecular orbital overlap matrix.</p>
<div class="math notranslate nohighlight">
\[S_{12} = \langle \Psi_A | \Psi_B \rangle
= (\mathrm{det}\mathbf{U}) (\mathrm{det}\mathbf{V^\dagger})
  \prod\limits_{i=1}\limits^{2N} \lambda_{ii}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{U}, \mathbf{V}, \lambda\)</span> are unitary matrices and single
values generated by single value decomposition(SVD) of the overlap matrix
<span class="math notranslate nohighlight">\(\mathbf{O}\)</span> which is the overlap matrix of two sets of molecular orbitals:</p>
<div class="math notranslate nohighlight">
\[\mathbf{U}^\dagger \mathbf{O} \mathbf{V} = \mathbf{\Lambda}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mo1</strong> – 2D ndarrays
Molecualr orbital coefficients</p></li>
<li><p><strong>mo2</strong> – 2D ndarrays
Molecualr orbital coefficients</p></li>
<li><p><strong>occ1</strong> – 2D ndarrays
occupation numbers</p></li>
<li><p><strong>occ2</strong> – 2D ndarrays
occupation numbers</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the product of single values: float
(x_a, x_b): 1D ndarrays
<span class="math notranslate nohighlight">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>
They are used to calculate asymmetric density matrix</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.diis">
<span class="sig-name descname"><span class="pre">diis</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.diis" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.diis_damp">
<span class="sig-name descname"><span class="pre">diis_damp</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.diis_damp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.diis_file">
<span class="sig-name descname"><span class="pre">diis_file</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.diis_file" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id17">
<span class="sig-name descname"><span class="pre">diis_space</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">8</span></em><a class="headerlink" href="#id17" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.diis_space_rollback">
<span class="sig-name descname"><span class="pre">diis_space_rollback</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.diis_space_rollback" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id18">
<span class="sig-name descname"><span class="pre">diis_start_cycle</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#id18" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.dip_moment">
<span class="sig-name descname"><span class="pre">dip_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'Debye'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.dip_moment" title="Link to this definition"></a></dt>
<dd><p>Dipole moment calculation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mu_x = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|x|\mu) + \sum_A Q_A X_A\\
\mu_y = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|y|\mu) + \sum_A Q_A Y_A\\
\mu_z = -\sum_{\mu}\sum_{\nu} P_{\mu\nu}(\nu|z|\mu) + \sum_A Q_A Z_A\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu_x, \mu_y, \mu_z\)</span> are the x, y and z components of dipole
moment</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – a 2D ndarrays density matrices</p></li>
<li><p><strong>origin</strong> – optional; length 3 list, tuple, or 1D array
Location of the origin. By default, the point (0, 0, 0) is used.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the dipole moment on x, y and z component</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.direct_scf">
<span class="sig-name descname"><span class="pre">direct_scf</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">True</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.direct_scf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.direct_scf_tol">
<span class="sig-name descname"><span class="pre">direct_scf_tol</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1e-13</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.direct_scf_tol" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.disp">
<span class="sig-name descname"><span class="pre">disp</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.disp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.do_disp">
<span class="sig-name descname"><span class="pre">do_disp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.do_disp" title="Link to this definition"></a></dt>
<dd><p>Check whether to apply dispersion correction based on the xc attribute.
If dispersion is allowed, return the DFTD3 disp version, such as d3bj,
d3zero, d4.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.dump_chk">
<span class="sig-name descname"><span class="pre">dump_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs_or_file</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.dump_chk" title="Link to this definition"></a></dt>
<dd><p>Serialize the SCF object and save it to the specified chkfile.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>envs_or_file</strong> – If this argument is a file path, the serialized SCF object is
saved to the file specified by this argument.
If this attribute is a dict (created by locals()), the necessary
variables are saved to the file specified by the attribute mf.chkfile.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.dump_flags">
<span class="sig-name descname"><span class="pre">dump_flags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.dump_flags" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.dump_scf_summary">
<span class="sig-name descname"><span class="pre">dump_scf_summary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.dump_scf_summary" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fock</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.eig" title="Link to this definition"></a></dt>
<dd><p>Solver for generalized eigenvalue problem</p>
<div class="math notranslate nohighlight">
\[HC = SCE\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.energy_elec">
<span class="sig-name descname"><span class="pre">energy_elec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.energy_elec" title="Link to this definition"></a></dt>
<dd><p>Electronic energy of Unrestricted Hartree-Fock</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Hartree-Fock electronic energy and the 2-electron part contribution</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.energy_nuc">
<span class="sig-name descname"><span class="pre">energy_nuc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.energy_nuc" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.energy_tot">
<span class="sig-name descname"><span class="pre">energy_tot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.energy_tot" title="Link to this definition"></a></dt>
<dd><p>Total Hartree-Fock energy, electronic part plus nuclear repulsion
See <code class="xref py py-func docutils literal notranslate"><span class="pre">scf.hf.energy_elec()</span></code> for the electron part</p>
<p>Note this function has side effects which cause mf.scf_summary updated.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.from_chk">
<span class="sig-name descname"><span class="pre">from_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.from_chk" title="Link to this definition"></a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.gen_response">
<span class="sig-name descname"><span class="pre">gen_response</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_j</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_memory</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_nlc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.gen_response" title="Link to this definition"></a></dt>
<dd><p>Generate a function to compute the product of UHF response function and
UHF density matrices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.get_dispersion">
<span class="sig-name descname"><span class="pre">get_dispersion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">disp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">with_3body</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.get_dispersion" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.get_fock">
<span class="sig-name descname"><span class="pre">get_fock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s1e</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diis_start_cycle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level_shift_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">damp_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.get_fock" title="Link to this definition"></a></dt>
<dd><p>F = h^{core} + V^{HF}</p>
<p>Special treatment (damping, DIIS, or level shift) will be applied to the
Fock matrix if diis and cycle is specified (The two parameters are passed
to get_fock function during the SCF iteration)</p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>h1e<span class="classifier">2D ndarray</span></dt><dd><p>Core hamiltonian</p>
</dd>
<dt>s1e<span class="classifier">2D ndarray</span></dt><dd><p>Overlap matrix, for DIIS</p>
</dd>
<dt>vhf<span class="classifier">2D ndarray</span></dt><dd><p>HF potential matrix</p>
</dd>
<dt>dm<span class="classifier">2D ndarray</span></dt><dd><p>Density matrix, for DIIS</p>
</dd>
<dt>cycle<span class="classifier">int</span></dt><dd><p>Then present SCF iteration step, for DIIS</p>
</dd>
<dt>diis<span class="classifier">an object of <code class="xref py py-attr docutils literal notranslate"><span class="pre">SCF.DIIS</span></code> class</span></dt><dd><p>DIIS object to hold intermediate Fock and error vectors</p>
</dd>
<dt>diis_start_cycle<span class="classifier">int</span></dt><dd><p>The step to start DIIS.  Default is 0.</p>
</dd>
<dt>level_shift_factor<span class="classifier">float or int</span></dt><dd><p>Level shift (in AU) for virtual space.  Default is 0.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.get_grad">
<span class="sig-name descname"><span class="pre">get_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fock</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.get_grad" title="Link to this definition"></a></dt>
<dd><p>RHF orbital gradients</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mo_coeff</strong> – 2D ndarray
Obital coefficients</p></li>
<li><p><strong>mo_occ</strong> – 1D ndarray
Orbital occupancy</p></li>
<li><p><strong>fock_ao</strong> – 2D ndarray
Fock matrix in AO representation</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Gradients in MO representation.  It’s a num_occ*num_vir vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.get_hcore">
<span class="sig-name descname"><span class="pre">get_hcore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.get_hcore" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.get_j">
<span class="sig-name descname"><span class="pre">get_j</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.get_j" title="Link to this definition"></a></dt>
<dd><p>Compute J matrices for all input density matrices</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.get_k">
<span class="sig-name descname"><span class="pre">get_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.get_k" title="Link to this definition"></a></dt>
<dd><p>Compute K matrices for all input density matrices</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.get_occ">
<span class="sig-name descname"><span class="pre">get_occ</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_energy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.get_occ" title="Link to this definition"></a></dt>
<dd><p>Label the occupancies for each orbital</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>mo_energy<span class="classifier">1D ndarray</span></dt><dd><p>Obital energies</p>
</dd>
<dt>mo_coeff<span class="classifier">2D ndarray</span></dt><dd><p>Obital coefficients</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">energy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">10.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">get_occ</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
<span class="go">array([2, 2, 0, 2, 2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.get_ovlp">
<span class="sig-name descname"><span class="pre">get_ovlp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.get_ovlp" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.get_veff">
<span class="sig-name descname"><span class="pre">get_veff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vhf_last</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hermi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.get_veff" title="Link to this definition"></a></dt>
<dd><p>Unrestricted Hartree-Fock potential matrix of alpha and beta spins,
for the given density matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}V_{ij}^\alpha &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\alpha \\
V_{ij}^\beta  &amp;= \sum_{kl} (ij|kl)(\gamma_{lk}^\alpha+\gamma_{lk}^\beta)
               - \sum_{kl} (il|kj)\gamma_{lk}^\beta\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – a list of ndarrays
A list of density matrices, stored as (alpha,alpha,…,beta,beta,…)</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>dm_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The density matrix baseline.  When it is not 0, this function computes
the increment of HF potential w.r.t. the reference HF potential matrix.</p>
</dd>
<dt>vhf_last<span class="classifier">ndarray or a list of ndarrays or 0</span></dt><dd><p>The reference HF potential matrix.</p>
</dd>
<dt>hermi<span class="classifier">int</span></dt><dd><p>Whether J, K matrix is hermitian</p>
<div class="line-block">
<div class="line">0 : no hermitian or symmetric</div>
<div class="line">1 : hermitian</div>
<div class="line">2 : anti-hermitian</div>
</div>
</dd>
<dt>vhfopt :</dt><dd><p>A class which holds precomputed quantities to optimize the
computation of J, K matrices</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><span class="math notranslate nohighlight">\(V_{hf} = (V^\alpha, V^\beta)\)</span>.  <span class="math notranslate nohighlight">\(V^\alpha\)</span> (and <span class="math notranslate nohighlight">\(V^\beta\)</span>)
can be a list matrices, corresponding to the input density matrices.</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; H 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dmsb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">(),</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dmsa</span><span class="p">,</span><span class="n">dmsb</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dms</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(6, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="p">,</span> <span class="n">vhfb</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">uhf</span><span class="o">.</span><span class="n">get_veff</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">dms</span><span class="p">,</span> <span class="n">hermi</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfa</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vhfb</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(3, 2, 2)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.init_direct_scf">
<span class="sig-name descname"><span class="pre">init_direct_scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.init_direct_scf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.init_guess">
<span class="sig-name descname"><span class="pre">init_guess</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'minao'</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.init_guess" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.init_guess_breaksym">
<span class="sig-name descname"><span class="pre">init_guess_breaksym</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.init_guess_breaksym" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.init_guess_by_1e">
<span class="sig-name descname"><span class="pre">init_guess_by_1e</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.init_guess_by_1e" title="Link to this definition"></a></dt>
<dd><p>Generate initial guess density matrix from core hamiltonian</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.init_guess_by_atom">
<span class="sig-name descname"><span class="pre">init_guess_by_atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.init_guess_by_atom" title="Link to this definition"></a></dt>
<dd><p>Generate initial guess density matrix from superposition of atomic HF
density matrix.  The atomic HF is occupancy averaged RHF</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.init_guess_by_chkfile">
<span class="sig-name descname"><span class="pre">init_guess_by_chkfile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">project</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.init_guess_by_chkfile" title="Link to this definition"></a></dt>
<dd><p>Read the HF results from checkpoint file, then project it to the
basis defined by <code class="docutils literal notranslate"><span class="pre">mol</span></code></p>
<dl>
<dt>Kwargs:</dt><dd><dl>
<dt>project<span class="classifier">None or bool</span></dt><dd><p>Whether to project chkfile’s orbitals to the new basis.  Note when
the geometry of the chkfile and the given molecule are very
different, this projection can produce very poor initial guess.
In PES scanning, it is recommended to switch off project.</p>
<p>If project is set to None, the projection is only applied when the
basis sets of the chkfile’s molecule are different to the basis
sets of the given molecule (regardless whether the geometry of
the two molecules are different).  Note the basis sets are
considered to be different if the two molecules are derived from
the same molecule with different ordering of atoms.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.init_guess_by_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.init_guess_by_huckel" title="Link to this definition"></a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.init_guess_by_minao">
<span class="sig-name descname"><span class="pre">init_guess_by_minao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.init_guess_by_minao" title="Link to this definition"></a></dt>
<dd><p>Initial guess in terms of the overlap to minimal basis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.init_guess_by_mod_huckel">
<span class="sig-name descname"><span class="pre">init_guess_by_mod_huckel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.init_guess_by_mod_huckel" title="Link to this definition"></a></dt>
<dd><p>Generate initial guess density matrix from a Huckel calculation based
on occupancy averaged atomic RHF calculations, doi:10.1021/acs.jctc.8b01089</p>
<p>In contrast to init_guess_by_huckel, this routine employs the
updated GWH rule from doi:10.1021/ja00480a005 to form the guess.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Density matrix, 2D ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.init_guess_by_sap">
<span class="sig-name descname"><span class="pre">init_guess_by_sap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">breaksym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.init_guess_by_sap" title="Link to this definition"></a></dt>
<dd><p>Generate initial guess density matrix from a superposition of
atomic potentials (SAP), doi:10.1021/acs.jctc.8b01089.
This is the Gaussian fit implementation, see doi:10.1063/5.0004046.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – MoleBase object
the molecule object for which the initial guess is evaluated</p></li>
<li><p><strong>sap_basis</strong> – dict
SAP basis in internal format (python dictionary)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>ndarray</dt><dd><p>SAP initial guess density matrix</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dm0</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.istype">
<span class="sig-name descname"><span class="pre">istype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">type_code</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.istype" title="Link to this definition"></a></dt>
<dd><p>Checks if the object is an instance of the class specified by the type_code.
type_code can be a class or a str. If the type_code is a class, it is
equivalent to the Python built-in function <cite>isinstance</cite>. If the type_code
is a str, it checks the type_code against the names of the object and all
its parent classes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.kernel">
<span class="sig-name descname"><span class="pre">kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.kernel" title="Link to this definition"></a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id19">
<span class="sig-name descname"><span class="pre">level_shift</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#id19" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.make_asym_dm">
<span class="sig-name descname"><span class="pre">make_asym_dm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occ2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.make_asym_dm" title="Link to this definition"></a></dt>
<dd><p>One-particle asymmetric density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mo1</strong> – 2D ndarrays
Molecualr orbital coefficients</p></li>
<li><p><strong>mo2</strong> – 2D ndarrays
Molecualr orbital coefficients</p></li>
<li><p><strong>occ1</strong> – 2D ndarrays
Occupation numbers</p></li>
<li><p><strong>occ2</strong> – 2D ndarrays
Occupation numbers</p></li>
<li><p><strong>x</strong> – 2D ndarrays
<span class="math notranslate nohighlight">\(\mathbf{U} \mathbf{\Lambda}^{-1} \mathbf{V}^\dagger\)</span>.
See also <a class="reference internal" href="#vayesta.lattmod.latt.LatticeUHF.det_ovlp" title="vayesta.lattmod.latt.LatticeUHF.det_ovlp"><code class="xref py py-func docutils literal notranslate"><span class="pre">det_ovlp()</span></code></a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of 2D ndarrays for alpha and beta spin</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mf1</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.3&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf2</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.4&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">intor_cross</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mol</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">det</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">det_ovlp</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span> <span class="o">=</span> <span class="n">make_asym_dm</span><span class="p">(</span><span class="n">mf1</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf1</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">mf2</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adm</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 19, 19)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.make_rdm1">
<span class="sig-name descname"><span class="pre">make_rdm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.make_rdm1" title="Link to this definition"></a></dt>
<dd><p>One-particle density matrix in AO representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mo_coeff</strong> – tuple of 2D ndarrays
Orbital coefficients for alpha and beta spins. Each column is one orbital.</p></li>
<li><p><strong>mo_occ</strong> – tuple of 1D ndarrays
Occupancies for alpha and beta spins.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of 2D ndarrays for alpha and beta spins</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.make_rdm2">
<span class="sig-name descname"><span class="pre">make_rdm2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mo_occ</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.make_rdm2" title="Link to this definition"></a></dt>
<dd><p>Two-particle density matrix in AO representation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mo_coeff</strong> – tuple of 2D ndarrays
Orbital coefficients for alpha and beta spins. Each column is one orbital.</p></li>
<li><p><strong>mo_occ</strong> – tuple of 1D ndarrays
Occupancies for alpha and beta spins.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple of three 4D ndarrays for alpha,alpha and alpha,beta and beta,beta spins</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id20">
<span class="sig-name descname"><span class="pre">max_cycle</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">50</span></em><a class="headerlink" href="#id20" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.mulliken_meta">
<span class="sig-name descname"><span class="pre">mulliken_meta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.mulliken_meta" title="Link to this definition"></a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – ndarray or 2-item list of ndarray
Density matrix.  ROHF dm is a 2-item list of 2D array</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.mulliken_meta_spin">
<span class="sig-name descname"><span class="pre">mulliken_meta_spin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pre_orth_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ANO'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.mulliken_meta_spin" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.mulliken_pop">
<span class="sig-name descname"><span class="pre">mulliken_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.mulliken_pop" title="Link to this definition"></a></dt>
<dd><p>Mulliken population analysis</p>
<div class="math notranslate nohighlight">
\[M_{ij} = D_{ij} S_{ji}\]</div>
<p>Mulliken charges</p>
<div class="math notranslate nohighlight">
\[\delta_i = \sum_j M_{ij}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.mulliken_pop_meta_lowdin_ao">
<span class="sig-name descname"><span class="pre">mulliken_pop_meta_lowdin_ao</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.mulliken_pop_meta_lowdin_ao" title="Link to this definition"></a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – ndarray or 2-item list of ndarray
Density matrix.  ROHF dm is a 2-item list of 2D array</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.mulliken_spin_pop">
<span class="sig-name descname"><span class="pre">mulliken_spin_pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.mulliken_spin_pop" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.multigrid_numint">
<span class="sig-name descname"><span class="pre">multigrid_numint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">margin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.multigrid_numint" title="Link to this definition"></a></dt>
<dd><p>Apply the MultiGrid algorithm for XC numerical integartion.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>margin<span class="classifier">float</span></dt><dd><p>A box will be created to enclose the molecule, with the molecule
positioned at the center. “margin” specifies the distance from
the edge of the molecule to the edge of the box. If not provided,
a default margin is estimated, which ensures that the electron
density decays to approximately 1e-7 at the boundary of the box.</p>
</dd>
<dt>mesh<span class="classifier">(3,) ndarray</span></dt><dd><p>The number of mesh grids along each axis. If not specified, the
number of mesh grids will be estimated based on the basis sets
and the margin.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.nelec">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelec</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.nelec" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.nelectron_alpha">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nelectron_alpha</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.nelectron_alpha" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.newton">
<span class="sig-name descname"><span class="pre">newton</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.newton" title="Link to this definition"></a></dt>
<dd><p>Create an SOSCF object based on the mean-field object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.nuc_grad_method">
<span class="sig-name descname"><span class="pre">nuc_grad_method</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.nuc_grad_method" title="Link to this definition"></a></dt>
<dd><p>Hook to create object for analytical nuclear gradients.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.opt">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">opt</span></span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.opt" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.pop" title="Link to this definition"></a></dt>
<dd><p>Mulliken population analysis, based on meta-Lowdin AOs.
In the meta-lowdin, the AOs are grouped in three sets: core, valence and
Rydberg, the orthogonalization are carried out within each subsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – ndarray or 2-item list of ndarray
Density matrix.  ROHF dm is a 2-item list of 2D array</p></li>
</ul>
</dd>
</dl>
<dl>
<dt>Kwargs:</dt><dd><p>verbose : int or instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">lib.logger.Logger</span></code></p>
<dl>
<dt>pre_orth_method<span class="classifier">str</span></dt><dd><p>Pre-orthogonalization, which localized GTOs for each atom.
To obtain the occupied and unoccupied atomic shells, there are
three methods</p>
<div class="line-block">
<div class="line">‘ano’   : Project GTOs to ANO basis</div>
<div class="line">‘minao’ : Project GTOs to MINAO basis</div>
<div class="line">‘scf’   : Symmetry-averaged fractional occupation atomic RHF</div>
</div>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>pop, charges</p>
<dl class="simple">
<dt>pop<span class="classifier">nparray</span></dt><dd><p>Mulliken population on each atomic orbitals</p>
</dd>
<dt>charges<span class="classifier">nparray</span></dt><dd><p>Mulliken charges</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>A list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.post_kernel">
<span class="sig-name descname"><span class="pre">post_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.post_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run after the main body of the kernel function.  Internal
variables are exposed to post_kernel through the “envs” dictionary.
Return value of post_kernel function is not required.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.pre_kernel">
<span class="sig-name descname"><span class="pre">pre_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">envs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.pre_kernel" title="Link to this definition"></a></dt>
<dd><p>A hook to be run before the main body of kernel function is executed.
Internal variables are exposed to pre_kernel through the “envs”
dictionary.  Return value of pre_kernel function is not required.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.quad_moment">
<span class="sig-name descname"><span class="pre">quad_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DebyeAngstrom'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.quad_moment" title="Link to this definition"></a></dt>
<dd><p>Calculates traceless quadrupole moment tensor.</p>
<p>The traceless quadrupole tensor is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}Q_{ij} &amp;= - \frac{1}{2} \sum_{\mu \nu} P_{\mu \nu}
        \left[ 3 (\nu | r_i r_j | \mu) - \delta_{ij} (\nu | r^2 | \mu) \right] \\
       &amp;+ \frac{1}{2} \sum_A Q_A
       \left( R_{iA} R_{jA} - \delta_{ij} \|\mathbf{R}_A\|^2  \right).\end{split}\]</div>
<p>If the molecule has a dipole, the quadrupole moment depends on the location
of the origin. By default, the origin is taken to be (0, 0, 0), but it can
be set manually via the keyword argument <cite>origin</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mol</strong> – an instance of <code class="xref py py-class docutils literal notranslate"><span class="pre">Mole</span></code></p></li>
<li><p><strong>dm</strong> – a 2D ndarrays density matrices</p></li>
<li><p><strong>origin</strong> – optional; length 3 list, tuple, or 1D array
Location of the origin. By default, it is (0, 0, 0).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Traceless quadrupole tensor, 2D ndarray.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.remove_soscf">
<span class="sig-name descname"><span class="pre">remove_soscf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.remove_soscf" title="Link to this definition"></a></dt>
<dd><p>Remove the SOSCF decorator</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.reset" title="Link to this definition"></a></dt>
<dd><p>Reset mol and relevant attributes associated to the old mol object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.run" title="Link to this definition"></a></dt>
<dd><p>Call the kernel function of current object.  <cite>args</cite> will be passed
to kernel function.  <cite>kwargs</cite> will be used to update the attributes of
current object.  The return value of method run is the object itself.
This allows a series of functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.sap_basis">
<span class="sig-name descname"><span class="pre">sap_basis</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'sapgrasplarge'</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.sap_basis" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.scf">
<span class="sig-name descname"><span class="pre">scf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dm0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.scf" title="Link to this definition"></a></dt>
<dd><p>SCF main driver</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>dm0<span class="classifier">ndarray</span></dt><dd><p>If given, it will be used as the initial guess density matrix</p>
</dd>
</dl>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">pyscf</span><span class="w"> </span><span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;H 0 0 0; F 0 0 1.1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">hf</span><span class="o">.</span><span class="n">SCF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dm_guess</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nao_nr</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">dm_guess</span><span class="p">)</span>
<span class="go">converged SCF energy = -98.5521904482821</span>
<span class="go">-98.552190448282104</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.set" title="Link to this definition"></a></dt>
<dd><p>Update the attributes of the current object.  The return value of
method set is the object itself.  This allows a series of
functions/methods to be executed in pipe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.sfx2c1e">
<span class="sig-name descname"><span class="pre">sfx2c1e</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.sfx2c1e" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.spin_square">
<span class="sig-name descname"><span class="pre">spin_square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mo_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.spin_square" title="Link to this definition"></a></dt>
<dd><p>Spin square and multiplicity of UHF determinant</p>
<div class="math notranslate nohighlight">
\[S^2 = \frac{1}{2}(S_+ S_-  +  S_- S_+) + S_z^2\]</div>
<p>where <span class="math notranslate nohighlight">\(S_+ = \sum_i S_{i+}\)</span> is effective for all beta occupied
orbitals; <span class="math notranslate nohighlight">\(S_- = \sum_i S_{i-}\)</span> is effective for all alpha occupied
orbitals.</p>
<ol class="arabic">
<li><dl>
<dt>There are two possibilities for <span class="math notranslate nohighlight">\(S_+ S_-\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron <span class="math notranslate nohighlight">\(S_+ S_- = \sum_i s_{i+} s_{i-}\)</span>,</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle UHF|s_{i+} s_{i-}|UHF\rangle
 = \sum_{pq}\langle p|s_+s_-|q\rangle \gamma_{qp} = n_\alpha\]</div>
<p>2) different electrons <span class="math notranslate nohighlight">\(S_+ S_- = \sum s_{i+} s_{j-},  (i\neq j)\)</span>.
There are in total <span class="math notranslate nohighlight">\(n(n-1)\)</span> terms.  As a two-particle operator,</p>
<div class="math notranslate nohighlight">
\[\langle S_+ S_- \rangle = \langle ij|s_+ s_-|ij\rangle
                        - \langle ij|s_+ s_-|ji\rangle
                        = -\langle i^\alpha|j^\beta\rangle
                           \langle j^\beta|i^\alpha\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>Similarly, for <span class="math notranslate nohighlight">\(S_- S_+\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\sum_i \langle s_{i-} s_{i+}\rangle = n_\beta\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle S_- S_+ \rangle = -\langle i^\beta|j^\alpha\rangle
                           \langle j^\alpha|i^\beta\rangle\]</div>
</dd>
</dl>
</li>
<li><dl>
<dt>For <span class="math notranslate nohighlight">\(S_z^2\)</span></dt><dd><ol class="arabic simple">
<li><p>same electron</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\langle s_z^2\rangle = \frac{1}{4}(n_\alpha + n_\beta)\]</div>
<ol class="arabic simple" start="2">
<li><p>different electrons</p></li>
</ol>
<div class="math notranslate nohighlight">
\[\begin{split}&amp;\frac{1}{2}\sum_{ij}(\langle ij|2s_{z1}s_{z2}|ij\rangle
                     -\langle ij|2s_{z1}s_{z2}|ji\rangle) \\
&amp;=\frac{1}{4}(\langle i^\alpha|i^\alpha\rangle \langle j^\alpha|j^\alpha\rangle
 - \langle i^\alpha|i^\alpha\rangle \langle j^\beta|j^\beta\rangle
 - \langle i^\beta|i^\beta\rangle \langle j^\alpha|j^\alpha\rangle
 + \langle i^\beta|i^\beta\rangle \langle j^\beta|j^\beta\rangle) \\
&amp;-\frac{1}{4}(\langle i^\alpha|j^\alpha\rangle \langle j^\alpha|i^\alpha\rangle
 + \langle i^\beta|j^\beta\rangle\langle j^\beta|i^\beta\rangle) \\
&amp;=\frac{1}{4}(n_\alpha^2 - n_\alpha n_\beta - n_\beta n_\alpha + n_\beta^2)
 -\frac{1}{4}(n_\alpha + n_\beta) \\
&amp;=\frac{1}{4}((n_\alpha-n_\beta)^2 - (n_\alpha+n_\beta))\end{split}\]</div>
</dd>
</dl>
</li>
</ol>
<p>In total</p>
<div class="math notranslate nohighlight">
\[\begin{split}\langle S^2\rangle &amp;= \frac{1}{2}
(n_\alpha-\sum_{ij}\langle i^\alpha|j^\beta\rangle \langle j^\beta|i^\alpha\rangle
+n_\beta -\sum_{ij}\langle i^\beta|j^\alpha\rangle\langle j^\alpha|i^\beta\rangle)
+ \frac{1}{4}(n_\alpha-n_\beta)^2 \\\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mo</strong> – a list of 2 ndarrays
Occupied alpha and occupied beta orbitals</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>s<span class="classifier">ndarray</span></dt><dd><p>AO overlap</p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A list of two floats.  The first is the expectation value of S^2.
The second is the corresponding 2S+1</p>
</dd>
</dl>
<p>Examples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s1">&#39;O 0 0 0; H 0 0 1; H 0 1 0&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s1">&#39;ccpvdz&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-75.623975516256706</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mo</span> <span class="o">=</span> <span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_occ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;S^2 = </span><span class="si">%.7f</span><span class="s1">, 2S+1 = </span><span class="si">%.7f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spin_square</span><span class="p">(</span><span class="n">mo</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor</span><span class="p">(</span><span class="s1">&#39;int1e_ovlp_sph&#39;</span><span class="p">)))</span>
<span class="go">S^2 = 0.7570150, 2S+1 = 2.0070027</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.stability">
<span class="sig-name descname"><span class="pre">stability</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">internal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_status</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.stability" title="Link to this definition"></a></dt>
<dd><p>Stability analysis for UHF/UKS method.</p>
<p>See also pyscf.scf.stability.uhf_stability function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mf</strong> – UHF or UKS object</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>internal<span class="classifier">bool</span></dt><dd><p>Internal stability, within the UHF space.</p>
</dd>
<dt>external<span class="classifier">bool</span></dt><dd><p>External stability. Including the UHF -&gt; GHF and real -&gt; complex
stability analysis.</p>
</dd>
<dt>return_status: bool</dt><dd><p>Whether to return <cite>stable_i</cite> and <cite>stable_e</cite></p>
</dd>
</dl>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>If return_status is False (default), the return value includes
two set of orbitals, which are more close to the stable condition.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
<p>Else, another two boolean variables (indicating current status:
stable or unstable) are returned.
The first corresponds to the internal stability
and the second corresponds to the external stability.</p>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.stdout">
<span class="sig-name descname"><span class="pre">stdout</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;_io.TextIOWrapper</span> <span class="pre">name='&lt;stdout&gt;'</span> <span class="pre">mode='w'</span> <span class="pre">encoding='utf-8'&gt;</span></em><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.stdout" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.to_ghf">
<span class="sig-name descname"><span class="pre">to_ghf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.to_ghf" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a GHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.to_gks">
<span class="sig-name descname"><span class="pre">to_gks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.to_gks" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a GKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.to_gpu">
<span class="sig-name descname"><span class="pre">to_gpu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.to_gpu" title="Link to this definition"></a></dt>
<dd><p>Convert a method to its corresponding GPU variant, and recursively
converts all attributes of a method to cupy objects or gpu4pyscf objects.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.to_ks">
<span class="sig-name descname"><span class="pre">to_ks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.to_ks" title="Link to this definition"></a></dt>
<dd><p>Convert to UKS object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.to_rhf">
<span class="sig-name descname"><span class="pre">to_rhf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.to_rhf" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a RHF/ROHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.to_rks">
<span class="sig-name descname"><span class="pre">to_rks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.to_rks" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a RKS/ROKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.to_uhf">
<span class="sig-name descname"><span class="pre">to_uhf</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.to_uhf" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a UHF object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.to_uks">
<span class="sig-name descname"><span class="pre">to_uks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'HF'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.to_uks" title="Link to this definition"></a></dt>
<dd><p>Convert the input mean-field object to a UKS object.</p>
<p>Note this conversion only changes the class of the mean-field object.
The total energy and wave-function are the same as them in the input
mean-field object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.update" title="Link to this definition"></a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id38"><span class="problematic" id="id39">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.update_">
<span class="sig-name descname"><span class="pre">update_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.update_" title="Link to this definition"></a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id40"><span class="problematic" id="id41">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.update_from_chk">
<span class="sig-name descname"><span class="pre">update_from_chk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.update_from_chk" title="Link to this definition"></a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id42"><span class="problematic" id="id43">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.update_from_chk_">
<span class="sig-name descname"><span class="pre">update_from_chk_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chkfile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.update_from_chk_" title="Link to this definition"></a></dt>
<dd><p>Read attributes from the chkfile then replace the attributes of
current object.  It’s an alias of function <a href="#id44"><span class="problematic" id="id45">update_from_chk_</span></a>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="id21">
<span class="sig-name descname"><span class="pre">verbose</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#id21" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.view">
<span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.view" title="Link to this definition"></a></dt>
<dd><p>New view of object with the same attributes.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.x2c">
<span class="sig-name descname"><span class="pre">x2c</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.x2c" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="vayesta.lattmod.latt.LatticeUHF.x2c1e">
<span class="sig-name descname"><span class="pre">x2c1e</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#vayesta.lattmod.latt.LatticeUHF.x2c1e" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-vayesta.lattmod">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-vayesta.lattmod" title="Link to this heading"></a></h2>
<p>Lattice model module</p>
<dl class="py function">
<dt class="sig sig-object py" id="vayesta.lattmod.LatticeMF">
<span class="sig-prename descclassname"><span class="pre">vayesta.lattmod.</span></span><span class="sig-name descname"><span class="pre">LatticeMF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mol</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/vayesta/lattmod.html#LatticeMF"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#vayesta.lattmod.LatticeMF" title="Link to this definition"></a></dt>
<dd><p>Use RHF by default, unless spin is not zero.</p>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="vayesta.core.types.wf.html" class="btn btn-neutral float-left" title="vayesta.core.types.wf" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="vayesta.libs.html" class="btn btn-neutral float-right" title="vayesta.libs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>